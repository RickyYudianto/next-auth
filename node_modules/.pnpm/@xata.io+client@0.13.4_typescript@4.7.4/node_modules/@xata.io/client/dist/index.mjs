function notEmpty(value) {
  return value !== null && value !== void 0;
}
function compact(arr) {
  return arr.filter(notEmpty);
}
function isObject(value) {
  return Boolean(value) && typeof value === "object" && !Array.isArray(value);
}
function isDefined(value) {
  return value !== null && value !== void 0;
}
function isString(value) {
  return isDefined(value) && typeof value === "string";
}
function toBase64(value) {
  try {
    return btoa(value);
  } catch (err) {
    const buf = Buffer;
    return buf.from(value).toString("base64");
  }
}

function getEnvVariable(name) {
  try {
    if (isObject(process) && isString(process?.env?.[name])) {
      return process.env[name];
    }
  } catch (err) {
  }
  try {
    if (isObject(Deno) && isString(Deno?.env?.get(name))) {
      return Deno.env.get(name);
    }
  } catch (err) {
  }
}
async function getGitBranch() {
  try {
    if (typeof require === "function") {
      const req = require;
      return req("child_process").execSync("git branch --show-current", { encoding: "utf-8" }).trim();
    }
  } catch (err) {
  }
  try {
    if (isObject(Deno)) {
      const process2 = Deno.run({
        cmd: ["git", "branch", "--show-current"],
        stdout: "piped",
        stderr: "piped"
      });
      return new TextDecoder().decode(await process2.output()).trim();
    }
  } catch (err) {
  }
}

function getAPIKey() {
  try {
    return getEnvVariable("XATA_API_KEY") ?? XATA_API_KEY;
  } catch (err) {
    return void 0;
  }
}

function getFetchImplementation(userFetch) {
  const globalFetch = typeof fetch !== "undefined" ? fetch : void 0;
  const fetchImpl = userFetch ?? globalFetch;
  if (!fetchImpl) {
    throw new Error(`The \`fetch\` option passed to the Xata client is resolving to a falsy value and may not be correctly imported.`);
  }
  return fetchImpl;
}

const VERSION = "0.13.4";

class ErrorWithCause extends Error {
  constructor(message, options) {
    super(message, options);
  }
}
class FetcherError extends ErrorWithCause {
  constructor(status, data, requestId) {
    super(getMessage(data));
    this.status = status;
    this.errors = isBulkError(data) ? data.errors : void 0;
    this.requestId = requestId;
    if (data instanceof Error) {
      this.stack = data.stack;
      this.cause = data.cause;
    }
  }
  toString() {
    const error = super.toString();
    return `[${this.status}] (${this.requestId ?? "Unknown"}): ${error}`;
  }
}
function isBulkError(error) {
  return isObject(error) && Array.isArray(error.errors);
}
function isErrorWithMessage(error) {
  return isObject(error) && isString(error.message);
}
function getMessage(data) {
  if (data instanceof Error) {
    return data.message;
  } else if (isString(data)) {
    return data;
  } else if (isErrorWithMessage(data)) {
    return data.message;
  } else if (isBulkError(data)) {
    return "Bulk operation failed";
  } else {
    return "Unexpected error";
  }
}

const resolveUrl = (url, queryParams = {}, pathParams = {}) => {
  const cleanQueryParams = Object.entries(queryParams).reduce((acc, [key, value]) => {
    if (value === void 0 || value === null)
      return acc;
    return { ...acc, [key]: value };
  }, {});
  const query = new URLSearchParams(cleanQueryParams).toString();
  const queryString = query.length > 0 ? `?${query}` : "";
  return url.replace(/\{\w*\}/g, (key) => pathParams[key.slice(1, -1)]) + queryString;
};
function buildBaseUrl({
  path,
  workspacesApiUrl,
  apiUrl,
  pathParams
}) {
  if (!pathParams?.workspace)
    return `${apiUrl}${path}`;
  const url = typeof workspacesApiUrl === "string" ? `${workspacesApiUrl}${path}` : workspacesApiUrl(path, pathParams);
  return url.replace("{workspaceId}", pathParams.workspace);
}
function hostHeader(url) {
  const pattern = /.*:\/\/(?<host>[^/]+).*/;
  const { groups } = pattern.exec(url) ?? {};
  return groups?.host ? { Host: groups.host } : {};
}
async function fetch$1({
  url: path,
  method,
  body,
  headers,
  pathParams,
  queryParams,
  fetchImpl,
  apiKey,
  apiUrl,
  workspacesApiUrl
}) {
  const baseUrl = buildBaseUrl({ path, workspacesApiUrl, pathParams, apiUrl });
  const fullUrl = resolveUrl(baseUrl, queryParams, pathParams);
  const url = fullUrl.includes("localhost") ? fullUrl.replace(/^[^.]+\./, "http://") : fullUrl;
  const response = await fetchImpl(url, {
    method: method.toUpperCase(),
    body: body ? JSON.stringify(body) : void 0,
    headers: {
      "Content-Type": "application/json",
      "User-Agent": `Xata client-ts/${VERSION}`,
      ...headers,
      ...hostHeader(fullUrl),
      Authorization: `Bearer ${apiKey}`
    }
  });
  if (response.status === 204) {
    return {};
  }
  const requestId = response.headers?.get("x-request-id") ?? void 0;
  try {
    const jsonResponse = await response.json();
    if (response.ok) {
      return jsonResponse;
    }
    throw new FetcherError(response.status, jsonResponse, requestId);
  } catch (error) {
    throw new FetcherError(response.status, error, requestId);
  }
}

const getUser = (variables) => fetch$1({ url: "/user", method: "get", ...variables });
const updateUser = (variables) => fetch$1({ url: "/user", method: "put", ...variables });
const deleteUser = (variables) => fetch$1({ url: "/user", method: "delete", ...variables });
const getUserAPIKeys = (variables) => fetch$1({
  url: "/user/keys",
  method: "get",
  ...variables
});
const createUserAPIKey = (variables) => fetch$1({
  url: "/user/keys/{keyName}",
  method: "post",
  ...variables
});
const deleteUserAPIKey = (variables) => fetch$1({
  url: "/user/keys/{keyName}",
  method: "delete",
  ...variables
});
const createWorkspace = (variables) => fetch$1({
  url: "/workspaces",
  method: "post",
  ...variables
});
const getWorkspacesList = (variables) => fetch$1({
  url: "/workspaces",
  method: "get",
  ...variables
});
const getWorkspace = (variables) => fetch$1({
  url: "/workspaces/{workspaceId}",
  method: "get",
  ...variables
});
const updateWorkspace = (variables) => fetch$1({
  url: "/workspaces/{workspaceId}",
  method: "put",
  ...variables
});
const deleteWorkspace = (variables) => fetch$1({
  url: "/workspaces/{workspaceId}",
  method: "delete",
  ...variables
});
const getWorkspaceMembersList = (variables) => fetch$1({
  url: "/workspaces/{workspaceId}/members",
  method: "get",
  ...variables
});
const updateWorkspaceMemberRole = (variables) => fetch$1({ url: "/workspaces/{workspaceId}/members/{userId}", method: "put", ...variables });
const removeWorkspaceMember = (variables) => fetch$1({
  url: "/workspaces/{workspaceId}/members/{userId}",
  method: "delete",
  ...variables
});
const inviteWorkspaceMember = (variables) => fetch$1({ url: "/workspaces/{workspaceId}/invites", method: "post", ...variables });
const cancelWorkspaceMemberInvite = (variables) => fetch$1({
  url: "/workspaces/{workspaceId}/invites/{inviteId}",
  method: "delete",
  ...variables
});
const resendWorkspaceMemberInvite = (variables) => fetch$1({
  url: "/workspaces/{workspaceId}/invites/{inviteId}/resend",
  method: "post",
  ...variables
});
const acceptWorkspaceMemberInvite = (variables) => fetch$1({
  url: "/workspaces/{workspaceId}/invites/{inviteKey}/accept",
  method: "post",
  ...variables
});
const getDatabaseList = (variables) => fetch$1({
  url: "/dbs",
  method: "get",
  ...variables
});
const getBranchList = (variables) => fetch$1({
  url: "/dbs/{dbName}",
  method: "get",
  ...variables
});
const createDatabase = (variables) => fetch$1({
  url: "/dbs/{dbName}",
  method: "put",
  ...variables
});
const deleteDatabase = (variables) => fetch$1({
  url: "/dbs/{dbName}",
  method: "delete",
  ...variables
});
const getGitBranchesMapping = (variables) => fetch$1({ url: "/dbs/{dbName}/gitBranches", method: "get", ...variables });
const addGitBranchesEntry = (variables) => fetch$1({ url: "/dbs/{dbName}/gitBranches", method: "post", ...variables });
const removeGitBranchesEntry = (variables) => fetch$1({ url: "/dbs/{dbName}/gitBranches", method: "delete", ...variables });
const resolveBranch = (variables) => fetch$1({
  url: "/dbs/{dbName}/resolveBranch",
  method: "get",
  ...variables
});
const getBranchDetails = (variables) => fetch$1({
  url: "/db/{dbBranchName}",
  method: "get",
  ...variables
});
const createBranch = (variables) => fetch$1({
  url: "/db/{dbBranchName}",
  method: "put",
  ...variables
});
const deleteBranch = (variables) => fetch$1({
  url: "/db/{dbBranchName}",
  method: "delete",
  ...variables
});
const updateBranchMetadata = (variables) => fetch$1({
  url: "/db/{dbBranchName}/metadata",
  method: "put",
  ...variables
});
const getBranchMetadata = (variables) => fetch$1({
  url: "/db/{dbBranchName}/metadata",
  method: "get",
  ...variables
});
const getBranchMigrationHistory = (variables) => fetch$1({ url: "/db/{dbBranchName}/migrations", method: "get", ...variables });
const executeBranchMigrationPlan = (variables) => fetch$1({ url: "/db/{dbBranchName}/migrations/execute", method: "post", ...variables });
const getBranchMigrationPlan = (variables) => fetch$1({ url: "/db/{dbBranchName}/migrations/plan", method: "post", ...variables });
const getBranchStats = (variables) => fetch$1({
  url: "/db/{dbBranchName}/stats",
  method: "get",
  ...variables
});
const createTable = (variables) => fetch$1({
  url: "/db/{dbBranchName}/tables/{tableName}",
  method: "put",
  ...variables
});
const deleteTable = (variables) => fetch$1({
  url: "/db/{dbBranchName}/tables/{tableName}",
  method: "delete",
  ...variables
});
const updateTable = (variables) => fetch$1({
  url: "/db/{dbBranchName}/tables/{tableName}",
  method: "patch",
  ...variables
});
const getTableSchema = (variables) => fetch$1({
  url: "/db/{dbBranchName}/tables/{tableName}/schema",
  method: "get",
  ...variables
});
const setTableSchema = (variables) => fetch$1({
  url: "/db/{dbBranchName}/tables/{tableName}/schema",
  method: "put",
  ...variables
});
const getTableColumns = (variables) => fetch$1({
  url: "/db/{dbBranchName}/tables/{tableName}/columns",
  method: "get",
  ...variables
});
const addTableColumn = (variables) => fetch$1({
  url: "/db/{dbBranchName}/tables/{tableName}/columns",
  method: "post",
  ...variables
});
const getColumn = (variables) => fetch$1({
  url: "/db/{dbBranchName}/tables/{tableName}/columns/{columnName}",
  method: "get",
  ...variables
});
const deleteColumn = (variables) => fetch$1({
  url: "/db/{dbBranchName}/tables/{tableName}/columns/{columnName}",
  method: "delete",
  ...variables
});
const updateColumn = (variables) => fetch$1({
  url: "/db/{dbBranchName}/tables/{tableName}/columns/{columnName}",
  method: "patch",
  ...variables
});
const insertRecord = (variables) => fetch$1({
  url: "/db/{dbBranchName}/tables/{tableName}/data",
  method: "post",
  ...variables
});
const insertRecordWithID = (variables) => fetch$1({ url: "/db/{dbBranchName}/tables/{tableName}/data/{recordId}", method: "put", ...variables });
const updateRecordWithID = (variables) => fetch$1({ url: "/db/{dbBranchName}/tables/{tableName}/data/{recordId}", method: "patch", ...variables });
const upsertRecordWithID = (variables) => fetch$1({ url: "/db/{dbBranchName}/tables/{tableName}/data/{recordId}", method: "post", ...variables });
const deleteRecord = (variables) => fetch$1({
  url: "/db/{dbBranchName}/tables/{tableName}/data/{recordId}",
  method: "delete",
  ...variables
});
const getRecord = (variables) => fetch$1({
  url: "/db/{dbBranchName}/tables/{tableName}/data/{recordId}",
  method: "get",
  ...variables
});
const bulkInsertTableRecords = (variables) => fetch$1({ url: "/db/{dbBranchName}/tables/{tableName}/bulk", method: "post", ...variables });
const queryTable = (variables) => fetch$1({
  url: "/db/{dbBranchName}/tables/{tableName}/query",
  method: "post",
  ...variables
});
const searchTable = (variables) => fetch$1({
  url: "/db/{dbBranchName}/tables/{tableName}/search",
  method: "post",
  ...variables
});
const searchBranch = (variables) => fetch$1({
  url: "/db/{dbBranchName}/search",
  method: "post",
  ...variables
});
const operationsByTag = {
  users: { getUser, updateUser, deleteUser, getUserAPIKeys, createUserAPIKey, deleteUserAPIKey },
  workspaces: {
    createWorkspace,
    getWorkspacesList,
    getWorkspace,
    updateWorkspace,
    deleteWorkspace,
    getWorkspaceMembersList,
    updateWorkspaceMemberRole,
    removeWorkspaceMember,
    inviteWorkspaceMember,
    cancelWorkspaceMemberInvite,
    resendWorkspaceMemberInvite,
    acceptWorkspaceMemberInvite
  },
  database: {
    getDatabaseList,
    createDatabase,
    deleteDatabase,
    getGitBranchesMapping,
    addGitBranchesEntry,
    removeGitBranchesEntry,
    resolveBranch
  },
  branch: {
    getBranchList,
    getBranchDetails,
    createBranch,
    deleteBranch,
    updateBranchMetadata,
    getBranchMetadata,
    getBranchMigrationHistory,
    executeBranchMigrationPlan,
    getBranchMigrationPlan,
    getBranchStats
  },
  table: {
    createTable,
    deleteTable,
    updateTable,
    getTableSchema,
    setTableSchema,
    getTableColumns,
    addTableColumn,
    getColumn,
    deleteColumn,
    updateColumn
  },
  records: {
    insertRecord,
    insertRecordWithID,
    updateRecordWithID,
    upsertRecordWithID,
    deleteRecord,
    getRecord,
    bulkInsertTableRecords,
    queryTable,
    searchTable,
    searchBranch
  }
};

function getHostUrl(provider, type) {
  if (isValidAlias(provider)) {
    return providers[provider][type];
  } else if (isValidBuilder(provider)) {
    return provider[type];
  }
  throw new Error("Invalid API provider");
}
const providers = {
  production: {
    main: "https://api.xata.io",
    workspaces: "https://{workspaceId}.xata.sh"
  },
  staging: {
    main: "https://staging.xatabase.co",
    workspaces: "https://{workspaceId}.staging.xatabase.co"
  }
};
function isValidAlias(alias) {
  return isString(alias) && Object.keys(providers).includes(alias);
}
function isValidBuilder(builder) {
  return isObject(builder) && isString(builder.main) && isString(builder.workspaces);
}

var __accessCheck$7 = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet$7 = (obj, member, getter) => {
  __accessCheck$7(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd$7 = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet$6 = (obj, member, value, setter) => {
  __accessCheck$7(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
var _extraProps, _namespaces;
class XataApiClient {
  constructor(options = {}) {
    __privateAdd$7(this, _extraProps, void 0);
    __privateAdd$7(this, _namespaces, {});
    const provider = options.host ?? "production";
    const apiKey = options?.apiKey ?? getAPIKey();
    if (!apiKey) {
      throw new Error("Could not resolve a valid apiKey");
    }
    __privateSet$6(this, _extraProps, {
      apiUrl: getHostUrl(provider, "main"),
      workspacesApiUrl: getHostUrl(provider, "workspaces"),
      fetchImpl: getFetchImplementation(options.fetch),
      apiKey
    });
  }
  get user() {
    if (!__privateGet$7(this, _namespaces).user)
      __privateGet$7(this, _namespaces).user = new UserApi(__privateGet$7(this, _extraProps));
    return __privateGet$7(this, _namespaces).user;
  }
  get workspaces() {
    if (!__privateGet$7(this, _namespaces).workspaces)
      __privateGet$7(this, _namespaces).workspaces = new WorkspaceApi(__privateGet$7(this, _extraProps));
    return __privateGet$7(this, _namespaces).workspaces;
  }
  get databases() {
    if (!__privateGet$7(this, _namespaces).databases)
      __privateGet$7(this, _namespaces).databases = new DatabaseApi(__privateGet$7(this, _extraProps));
    return __privateGet$7(this, _namespaces).databases;
  }
  get branches() {
    if (!__privateGet$7(this, _namespaces).branches)
      __privateGet$7(this, _namespaces).branches = new BranchApi(__privateGet$7(this, _extraProps));
    return __privateGet$7(this, _namespaces).branches;
  }
  get tables() {
    if (!__privateGet$7(this, _namespaces).tables)
      __privateGet$7(this, _namespaces).tables = new TableApi(__privateGet$7(this, _extraProps));
    return __privateGet$7(this, _namespaces).tables;
  }
  get records() {
    if (!__privateGet$7(this, _namespaces).records)
      __privateGet$7(this, _namespaces).records = new RecordsApi(__privateGet$7(this, _extraProps));
    return __privateGet$7(this, _namespaces).records;
  }
}
_extraProps = new WeakMap();
_namespaces = new WeakMap();
class UserApi {
  constructor(extraProps) {
    this.extraProps = extraProps;
  }
  getUser() {
    return operationsByTag.users.getUser({ ...this.extraProps });
  }
  updateUser(user) {
    return operationsByTag.users.updateUser({ body: user, ...this.extraProps });
  }
  deleteUser() {
    return operationsByTag.users.deleteUser({ ...this.extraProps });
  }
  getUserAPIKeys() {
    return operationsByTag.users.getUserAPIKeys({ ...this.extraProps });
  }
  createUserAPIKey(keyName) {
    return operationsByTag.users.createUserAPIKey({
      pathParams: { keyName },
      ...this.extraProps
    });
  }
  deleteUserAPIKey(keyName) {
    return operationsByTag.users.deleteUserAPIKey({
      pathParams: { keyName },
      ...this.extraProps
    });
  }
}
class WorkspaceApi {
  constructor(extraProps) {
    this.extraProps = extraProps;
  }
  createWorkspace(workspaceMeta) {
    return operationsByTag.workspaces.createWorkspace({
      body: workspaceMeta,
      ...this.extraProps
    });
  }
  getWorkspacesList() {
    return operationsByTag.workspaces.getWorkspacesList({ ...this.extraProps });
  }
  getWorkspace(workspaceId) {
    return operationsByTag.workspaces.getWorkspace({
      pathParams: { workspaceId },
      ...this.extraProps
    });
  }
  updateWorkspace(workspaceId, workspaceMeta) {
    return operationsByTag.workspaces.updateWorkspace({
      pathParams: { workspaceId },
      body: workspaceMeta,
      ...this.extraProps
    });
  }
  deleteWorkspace(workspaceId) {
    return operationsByTag.workspaces.deleteWorkspace({
      pathParams: { workspaceId },
      ...this.extraProps
    });
  }
  getWorkspaceMembersList(workspaceId) {
    return operationsByTag.workspaces.getWorkspaceMembersList({
      pathParams: { workspaceId },
      ...this.extraProps
    });
  }
  updateWorkspaceMemberRole(workspaceId, userId, role) {
    return operationsByTag.workspaces.updateWorkspaceMemberRole({
      pathParams: { workspaceId, userId },
      body: { role },
      ...this.extraProps
    });
  }
  removeWorkspaceMember(workspaceId, userId) {
    return operationsByTag.workspaces.removeWorkspaceMember({
      pathParams: { workspaceId, userId },
      ...this.extraProps
    });
  }
  inviteWorkspaceMember(workspaceId, email, role) {
    return operationsByTag.workspaces.inviteWorkspaceMember({
      pathParams: { workspaceId },
      body: { email, role },
      ...this.extraProps
    });
  }
  cancelWorkspaceMemberInvite(workspaceId, inviteId) {
    return operationsByTag.workspaces.cancelWorkspaceMemberInvite({
      pathParams: { workspaceId, inviteId },
      ...this.extraProps
    });
  }
  resendWorkspaceMemberInvite(workspaceId, inviteId) {
    return operationsByTag.workspaces.resendWorkspaceMemberInvite({
      pathParams: { workspaceId, inviteId },
      ...this.extraProps
    });
  }
  acceptWorkspaceMemberInvite(workspaceId, inviteKey) {
    return operationsByTag.workspaces.acceptWorkspaceMemberInvite({
      pathParams: { workspaceId, inviteKey },
      ...this.extraProps
    });
  }
}
class DatabaseApi {
  constructor(extraProps) {
    this.extraProps = extraProps;
  }
  getDatabaseList(workspace) {
    return operationsByTag.database.getDatabaseList({
      pathParams: { workspace },
      ...this.extraProps
    });
  }
  createDatabase(workspace, dbName, options = {}) {
    return operationsByTag.database.createDatabase({
      pathParams: { workspace, dbName },
      body: options,
      ...this.extraProps
    });
  }
  deleteDatabase(workspace, dbName) {
    return operationsByTag.database.deleteDatabase({
      pathParams: { workspace, dbName },
      ...this.extraProps
    });
  }
  getGitBranchesMapping(workspace, dbName) {
    return operationsByTag.database.getGitBranchesMapping({
      pathParams: { workspace, dbName },
      ...this.extraProps
    });
  }
  addGitBranchesEntry(workspace, dbName, body) {
    return operationsByTag.database.addGitBranchesEntry({
      pathParams: { workspace, dbName },
      body,
      ...this.extraProps
    });
  }
  removeGitBranchesEntry(workspace, dbName, gitBranch) {
    return operationsByTag.database.removeGitBranchesEntry({
      pathParams: { workspace, dbName },
      queryParams: { gitBranch },
      ...this.extraProps
    });
  }
  resolveBranch(workspace, dbName, gitBranch, fallbackBranch) {
    return operationsByTag.database.resolveBranch({
      pathParams: { workspace, dbName },
      queryParams: { gitBranch, fallbackBranch },
      ...this.extraProps
    });
  }
}
class BranchApi {
  constructor(extraProps) {
    this.extraProps = extraProps;
  }
  getBranchList(workspace, dbName) {
    return operationsByTag.branch.getBranchList({
      pathParams: { workspace, dbName },
      ...this.extraProps
    });
  }
  getBranchDetails(workspace, database, branch) {
    return operationsByTag.branch.getBranchDetails({
      pathParams: { workspace, dbBranchName: `${database}:${branch}` },
      ...this.extraProps
    });
  }
  createBranch(workspace, database, branch, from, options = {}) {
    return operationsByTag.branch.createBranch({
      pathParams: { workspace, dbBranchName: `${database}:${branch}` },
      queryParams: isString(from) ? { from } : void 0,
      body: options,
      ...this.extraProps
    });
  }
  deleteBranch(workspace, database, branch) {
    return operationsByTag.branch.deleteBranch({
      pathParams: { workspace, dbBranchName: `${database}:${branch}` },
      ...this.extraProps
    });
  }
  updateBranchMetadata(workspace, database, branch, metadata = {}) {
    return operationsByTag.branch.updateBranchMetadata({
      pathParams: { workspace, dbBranchName: `${database}:${branch}` },
      body: metadata,
      ...this.extraProps
    });
  }
  getBranchMetadata(workspace, database, branch) {
    return operationsByTag.branch.getBranchMetadata({
      pathParams: { workspace, dbBranchName: `${database}:${branch}` },
      ...this.extraProps
    });
  }
  getBranchMigrationHistory(workspace, database, branch, options = {}) {
    return operationsByTag.branch.getBranchMigrationHistory({
      pathParams: { workspace, dbBranchName: `${database}:${branch}` },
      body: options,
      ...this.extraProps
    });
  }
  executeBranchMigrationPlan(workspace, database, branch, migrationPlan) {
    return operationsByTag.branch.executeBranchMigrationPlan({
      pathParams: { workspace, dbBranchName: `${database}:${branch}` },
      body: migrationPlan,
      ...this.extraProps
    });
  }
  getBranchMigrationPlan(workspace, database, branch, schema) {
    return operationsByTag.branch.getBranchMigrationPlan({
      pathParams: { workspace, dbBranchName: `${database}:${branch}` },
      body: schema,
      ...this.extraProps
    });
  }
  getBranchStats(workspace, database, branch) {
    return operationsByTag.branch.getBranchStats({
      pathParams: { workspace, dbBranchName: `${database}:${branch}` },
      ...this.extraProps
    });
  }
}
class TableApi {
  constructor(extraProps) {
    this.extraProps = extraProps;
  }
  createTable(workspace, database, branch, tableName) {
    return operationsByTag.table.createTable({
      pathParams: { workspace, dbBranchName: `${database}:${branch}`, tableName },
      ...this.extraProps
    });
  }
  deleteTable(workspace, database, branch, tableName) {
    return operationsByTag.table.deleteTable({
      pathParams: { workspace, dbBranchName: `${database}:${branch}`, tableName },
      ...this.extraProps
    });
  }
  updateTable(workspace, database, branch, tableName, options) {
    return operationsByTag.table.updateTable({
      pathParams: { workspace, dbBranchName: `${database}:${branch}`, tableName },
      body: options,
      ...this.extraProps
    });
  }
  getTableSchema(workspace, database, branch, tableName) {
    return operationsByTag.table.getTableSchema({
      pathParams: { workspace, dbBranchName: `${database}:${branch}`, tableName },
      ...this.extraProps
    });
  }
  setTableSchema(workspace, database, branch, tableName, options) {
    return operationsByTag.table.setTableSchema({
      pathParams: { workspace, dbBranchName: `${database}:${branch}`, tableName },
      body: options,
      ...this.extraProps
    });
  }
  getTableColumns(workspace, database, branch, tableName) {
    return operationsByTag.table.getTableColumns({
      pathParams: { workspace, dbBranchName: `${database}:${branch}`, tableName },
      ...this.extraProps
    });
  }
  addTableColumn(workspace, database, branch, tableName, column) {
    return operationsByTag.table.addTableColumn({
      pathParams: { workspace, dbBranchName: `${database}:${branch}`, tableName },
      body: column,
      ...this.extraProps
    });
  }
  getColumn(workspace, database, branch, tableName, columnName) {
    return operationsByTag.table.getColumn({
      pathParams: { workspace, dbBranchName: `${database}:${branch}`, tableName, columnName },
      ...this.extraProps
    });
  }
  deleteColumn(workspace, database, branch, tableName, columnName) {
    return operationsByTag.table.deleteColumn({
      pathParams: { workspace, dbBranchName: `${database}:${branch}`, tableName, columnName },
      ...this.extraProps
    });
  }
  updateColumn(workspace, database, branch, tableName, columnName, options) {
    return operationsByTag.table.updateColumn({
      pathParams: { workspace, dbBranchName: `${database}:${branch}`, tableName, columnName },
      body: options,
      ...this.extraProps
    });
  }
}
class RecordsApi {
  constructor(extraProps) {
    this.extraProps = extraProps;
  }
  insertRecord(workspace, database, branch, tableName, record) {
    return operationsByTag.records.insertRecord({
      pathParams: { workspace, dbBranchName: `${database}:${branch}`, tableName },
      body: record,
      ...this.extraProps
    });
  }
  insertRecordWithID(workspace, database, branch, tableName, recordId, record, options = {}) {
    return operationsByTag.records.insertRecordWithID({
      pathParams: { workspace, dbBranchName: `${database}:${branch}`, tableName, recordId },
      queryParams: options,
      body: record,
      ...this.extraProps
    });
  }
  updateRecordWithID(workspace, database, branch, tableName, recordId, record, options = {}) {
    return operationsByTag.records.updateRecordWithID({
      pathParams: { workspace, dbBranchName: `${database}:${branch}`, tableName, recordId },
      queryParams: options,
      body: record,
      ...this.extraProps
    });
  }
  upsertRecordWithID(workspace, database, branch, tableName, recordId, record, options = {}) {
    return operationsByTag.records.upsertRecordWithID({
      pathParams: { workspace, dbBranchName: `${database}:${branch}`, tableName, recordId },
      queryParams: options,
      body: record,
      ...this.extraProps
    });
  }
  deleteRecord(workspace, database, branch, tableName, recordId) {
    return operationsByTag.records.deleteRecord({
      pathParams: { workspace, dbBranchName: `${database}:${branch}`, tableName, recordId },
      ...this.extraProps
    });
  }
  getRecord(workspace, database, branch, tableName, recordId, options = {}) {
    return operationsByTag.records.getRecord({
      pathParams: { workspace, dbBranchName: `${database}:${branch}`, tableName, recordId },
      ...this.extraProps
    });
  }
  bulkInsertTableRecords(workspace, database, branch, tableName, records) {
    return operationsByTag.records.bulkInsertTableRecords({
      pathParams: { workspace, dbBranchName: `${database}:${branch}`, tableName },
      body: { records },
      ...this.extraProps
    });
  }
  queryTable(workspace, database, branch, tableName, query) {
    return operationsByTag.records.queryTable({
      pathParams: { workspace, dbBranchName: `${database}:${branch}`, tableName },
      body: query,
      ...this.extraProps
    });
  }
  searchTable(workspace, database, branch, tableName, query) {
    return operationsByTag.records.searchTable({
      pathParams: { workspace, dbBranchName: `${database}:${branch}`, tableName },
      body: query,
      ...this.extraProps
    });
  }
  searchBranch(workspace, database, branch, query) {
    return operationsByTag.records.searchBranch({
      pathParams: { workspace, dbBranchName: `${database}:${branch}` },
      body: query,
      ...this.extraProps
    });
  }
}

class XataApiPlugin {
  async build(options) {
    const { fetchImpl, apiKey } = await options.getFetchProps();
    return new XataApiClient({ fetch: fetchImpl, apiKey });
  }
}

class XataPlugin {
}

var __accessCheck$6 = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet$6 = (obj, member, getter) => {
  __accessCheck$6(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd$6 = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet$5 = (obj, member, value, setter) => {
  __accessCheck$6(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
var _query, _page;
class Page {
  constructor(query, meta, records = []) {
    __privateAdd$6(this, _query, void 0);
    __privateSet$5(this, _query, query);
    this.meta = meta;
    this.records = new RecordArray(this, records);
  }
  async nextPage(size, offset) {
    return __privateGet$6(this, _query).getPaginated({ pagination: { size, offset, after: this.meta.page.cursor } });
  }
  async previousPage(size, offset) {
    return __privateGet$6(this, _query).getPaginated({ pagination: { size, offset, before: this.meta.page.cursor } });
  }
  async firstPage(size, offset) {
    return __privateGet$6(this, _query).getPaginated({ pagination: { size, offset, first: this.meta.page.cursor } });
  }
  async lastPage(size, offset) {
    return __privateGet$6(this, _query).getPaginated({ pagination: { size, offset, last: this.meta.page.cursor } });
  }
  hasNextPage() {
    return this.meta.page.more;
  }
}
_query = new WeakMap();
const PAGINATION_MAX_SIZE = 200;
const PAGINATION_DEFAULT_SIZE = 20;
const PAGINATION_MAX_OFFSET = 800;
const PAGINATION_DEFAULT_OFFSET = 0;
function isCursorPaginationOptions(options) {
  return isDefined(options) && (isDefined(options.first) || isDefined(options.last) || isDefined(options.after) || isDefined(options.before));
}
const _RecordArray = class extends Array {
  constructor(page, overrideRecords) {
    super(..._RecordArray.parseConstructorParams(page, overrideRecords));
    __privateAdd$6(this, _page, void 0);
    __privateSet$5(this, _page, page);
  }
  static parseConstructorParams(...args) {
    if (args.length === 1 && typeof args[0] === "number") {
      return new Array(args[0]);
    }
    if (args.length <= 2 && isObject(args[0]?.meta) && Array.isArray(args[1] ?? [])) {
      const result = args[1] ?? args[0].records ?? [];
      return new Array(...result);
    }
    return new Array(...args);
  }
  async nextPage(size, offset) {
    const newPage = await __privateGet$6(this, _page).nextPage(size, offset);
    return new _RecordArray(newPage);
  }
  async previousPage(size, offset) {
    const newPage = await __privateGet$6(this, _page).previousPage(size, offset);
    return new _RecordArray(newPage);
  }
  async firstPage(size, offset) {
    const newPage = await __privateGet$6(this, _page).firstPage(size, offset);
    return new _RecordArray(newPage);
  }
  async lastPage(size, offset) {
    const newPage = await __privateGet$6(this, _page).lastPage(size, offset);
    return new _RecordArray(newPage);
  }
  hasNextPage() {
    return __privateGet$6(this, _page).meta.page.more;
  }
};
let RecordArray = _RecordArray;
_page = new WeakMap();

var __accessCheck$5 = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet$5 = (obj, member, getter) => {
  __accessCheck$5(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd$5 = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet$4 = (obj, member, value, setter) => {
  __accessCheck$5(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
var _table$1, _repository, _data;
const _Query = class {
  constructor(repository, table, data, rawParent) {
    __privateAdd$5(this, _table$1, void 0);
    __privateAdd$5(this, _repository, void 0);
    __privateAdd$5(this, _data, { filter: {} });
    this.meta = { page: { cursor: "start", more: true } };
    this.records = new RecordArray(this, []);
    __privateSet$4(this, _table$1, table);
    if (repository) {
      __privateSet$4(this, _repository, repository);
    } else {
      __privateSet$4(this, _repository, this);
    }
    const parent = cleanParent(data, rawParent);
    __privateGet$5(this, _data).filter = data.filter ?? parent?.filter ?? {};
    __privateGet$5(this, _data).filter.$any = data.filter?.$any ?? parent?.filter?.$any;
    __privateGet$5(this, _data).filter.$all = data.filter?.$all ?? parent?.filter?.$all;
    __privateGet$5(this, _data).filter.$not = data.filter?.$not ?? parent?.filter?.$not;
    __privateGet$5(this, _data).filter.$none = data.filter?.$none ?? parent?.filter?.$none;
    __privateGet$5(this, _data).sort = data.sort ?? parent?.sort;
    __privateGet$5(this, _data).columns = data.columns ?? parent?.columns ?? ["*"];
    __privateGet$5(this, _data).pagination = data.pagination ?? parent?.pagination;
    __privateGet$5(this, _data).cache = data.cache ?? parent?.cache;
    this.any = this.any.bind(this);
    this.all = this.all.bind(this);
    this.not = this.not.bind(this);
    this.filter = this.filter.bind(this);
    this.sort = this.sort.bind(this);
    this.none = this.none.bind(this);
    Object.defineProperty(this, "table", { enumerable: false });
    Object.defineProperty(this, "repository", { enumerable: false });
  }
  getQueryOptions() {
    return __privateGet$5(this, _data);
  }
  key() {
    const { columns = [], filter = {}, sort = [], pagination = {} } = __privateGet$5(this, _data);
    const key = JSON.stringify({ columns, filter, sort, pagination });
    return toBase64(key);
  }
  any(...queries) {
    const $any = queries.map((query) => query.getQueryOptions().filter ?? {});
    return new _Query(__privateGet$5(this, _repository), __privateGet$5(this, _table$1), { filter: { $any } }, __privateGet$5(this, _data));
  }
  all(...queries) {
    const $all = queries.map((query) => query.getQueryOptions().filter ?? {});
    return new _Query(__privateGet$5(this, _repository), __privateGet$5(this, _table$1), { filter: { $all } }, __privateGet$5(this, _data));
  }
  not(...queries) {
    const $not = queries.map((query) => query.getQueryOptions().filter ?? {});
    return new _Query(__privateGet$5(this, _repository), __privateGet$5(this, _table$1), { filter: { $not } }, __privateGet$5(this, _data));
  }
  none(...queries) {
    const $none = queries.map((query) => query.getQueryOptions().filter ?? {});
    return new _Query(__privateGet$5(this, _repository), __privateGet$5(this, _table$1), { filter: { $none } }, __privateGet$5(this, _data));
  }
  filter(a, b) {
    if (arguments.length === 1) {
      const constraints = Object.entries(a).map(([column, constraint]) => ({ [column]: constraint }));
      const $all = compact([__privateGet$5(this, _data).filter?.$all].flat().concat(constraints));
      return new _Query(__privateGet$5(this, _repository), __privateGet$5(this, _table$1), { filter: { $all } }, __privateGet$5(this, _data));
    } else {
      const $all = compact([__privateGet$5(this, _data).filter?.$all].flat().concat([{ [a]: b }]));
      return new _Query(__privateGet$5(this, _repository), __privateGet$5(this, _table$1), { filter: { $all } }, __privateGet$5(this, _data));
    }
  }
  sort(column, direction) {
    const originalSort = [__privateGet$5(this, _data).sort ?? []].flat();
    const sort = [...originalSort, { column, direction }];
    return new _Query(__privateGet$5(this, _repository), __privateGet$5(this, _table$1), { sort }, __privateGet$5(this, _data));
  }
  select(columns) {
    return new _Query(__privateGet$5(this, _repository), __privateGet$5(this, _table$1), { columns }, __privateGet$5(this, _data));
  }
  getPaginated(options = {}) {
    const query = new _Query(__privateGet$5(this, _repository), __privateGet$5(this, _table$1), options, __privateGet$5(this, _data));
    return __privateGet$5(this, _repository).query(query);
  }
  async *[Symbol.asyncIterator]() {
    for await (const [record] of this.getIterator({ batchSize: 1 })) {
      yield record;
    }
  }
  async *getIterator(options = {}) {
    const { batchSize = 1 } = options;
    let page = await this.getPaginated({ ...options, pagination: { size: batchSize, offset: 0 } });
    let more = page.hasNextPage();
    yield page.records;
    while (more) {
      page = await page.nextPage();
      more = page.hasNextPage();
      yield page.records;
    }
  }
  async getMany(options = {}) {
    const page = await this.getPaginated(options);
    if (page.hasNextPage() && options.pagination?.size === void 0) {
      console.trace("Calling getMany does not return all results. Paginate to get all results or call getAll.");
    }
    return page.records;
  }
  async getAll(options = {}) {
    const { batchSize = PAGINATION_MAX_SIZE, ...rest } = options;
    const results = [];
    for await (const page of this.getIterator({ ...rest, batchSize })) {
      results.push(...page);
    }
    return results;
  }
  async getFirst(options = {}) {
    const records = await this.getMany({ ...options, pagination: { size: 1 } });
    return records[0] ?? null;
  }
  cache(ttl) {
    return new _Query(__privateGet$5(this, _repository), __privateGet$5(this, _table$1), { cache: ttl }, __privateGet$5(this, _data));
  }
  nextPage(size, offset) {
    return this.firstPage(size, offset);
  }
  previousPage(size, offset) {
    return this.firstPage(size, offset);
  }
  firstPage(size, offset) {
    return this.getPaginated({ pagination: { size, offset } });
  }
  lastPage(size, offset) {
    return this.getPaginated({ pagination: { size, offset, before: "end" } });
  }
  hasNextPage() {
    return this.meta.page.more;
  }
};
let Query = _Query;
_table$1 = new WeakMap();
_repository = new WeakMap();
_data = new WeakMap();
function cleanParent(data, parent) {
  if (isCursorPaginationOptions(data.pagination)) {
    return { ...parent, sorting: void 0, filter: void 0 };
  }
  return parent;
}

function isIdentifiable(x) {
  return isObject(x) && isString(x?.id);
}
function isXataRecord(x) {
  const record = x;
  const metadata = record?.getMetadata();
  return isIdentifiable(x) && isObject(metadata) && typeof metadata.version === "number";
}

function isSortFilterString(value) {
  return isString(value);
}
function isSortFilterBase(filter) {
  return isObject(filter) && Object.values(filter).every((value) => value === "asc" || value === "desc");
}
function isSortFilterObject(filter) {
  return isObject(filter) && !isSortFilterBase(filter) && filter.column !== void 0;
}
function buildSortFilter(filter) {
  if (isSortFilterString(filter)) {
    return { [filter]: "asc" };
  } else if (Array.isArray(filter)) {
    return filter.map((item) => buildSortFilter(item));
  } else if (isSortFilterBase(filter)) {
    return filter;
  } else if (isSortFilterObject(filter)) {
    return { [filter.column]: filter.direction ?? "asc" };
  } else {
    throw new Error(`Invalid sort filter: ${filter}`);
  }
}

var __accessCheck$4 = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet$4 = (obj, member, getter) => {
  __accessCheck$4(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd$4 = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet$3 = (obj, member, value, setter) => {
  __accessCheck$4(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
var __privateMethod$2 = (obj, member, method) => {
  __accessCheck$4(obj, member, "access private method");
  return method;
};
var _table, _getFetchProps, _cache, _schema$1, _insertRecordWithoutId, insertRecordWithoutId_fn, _insertRecordWithId, insertRecordWithId_fn, _bulkInsertTableRecords, bulkInsertTableRecords_fn, _updateRecordWithID, updateRecordWithID_fn, _upsertRecordWithID, upsertRecordWithID_fn, _deleteRecord, deleteRecord_fn, _invalidateCache, invalidateCache_fn, _setCacheRecord, setCacheRecord_fn, _getCacheRecord, getCacheRecord_fn, _setCacheQuery, setCacheQuery_fn, _getCacheQuery, getCacheQuery_fn, _getSchema$1, getSchema_fn$1;
class Repository extends Query {
}
class RestRepository extends Query {
  constructor(options) {
    super(null, options.table, {});
    __privateAdd$4(this, _insertRecordWithoutId);
    __privateAdd$4(this, _insertRecordWithId);
    __privateAdd$4(this, _bulkInsertTableRecords);
    __privateAdd$4(this, _updateRecordWithID);
    __privateAdd$4(this, _upsertRecordWithID);
    __privateAdd$4(this, _deleteRecord);
    __privateAdd$4(this, _invalidateCache);
    __privateAdd$4(this, _setCacheRecord);
    __privateAdd$4(this, _getCacheRecord);
    __privateAdd$4(this, _setCacheQuery);
    __privateAdd$4(this, _getCacheQuery);
    __privateAdd$4(this, _getSchema$1);
    __privateAdd$4(this, _table, void 0);
    __privateAdd$4(this, _getFetchProps, void 0);
    __privateAdd$4(this, _cache, void 0);
    __privateAdd$4(this, _schema$1, void 0);
    __privateSet$3(this, _table, options.table);
    __privateSet$3(this, _getFetchProps, options.pluginOptions.getFetchProps);
    this.db = options.db;
    __privateSet$3(this, _cache, options.pluginOptions.cache);
  }
  async create(a, b) {
    if (Array.isArray(a)) {
      if (a.length === 0)
        return [];
      const [itemsWithoutIds, itemsWithIds, order] = a.reduce(([accWithoutIds, accWithIds, accOrder], item) => {
        const condition = isString(item.id);
        accOrder.push(condition);
        if (condition) {
          accWithIds.push(item);
        } else {
          accWithoutIds.push(item);
        }
        return [accWithoutIds, accWithIds, accOrder];
      }, [[], [], []]);
      const recordsWithoutId = await __privateMethod$2(this, _bulkInsertTableRecords, bulkInsertTableRecords_fn).call(this, itemsWithoutIds);
      await Promise.all(recordsWithoutId.map((record) => __privateMethod$2(this, _setCacheRecord, setCacheRecord_fn).call(this, record)));
      if (itemsWithIds.length > 100) {
        console.warn("Bulk create operation with id is not optimized in the Xata API yet, this request might be slow");
      }
      const recordsWithId = await Promise.all(itemsWithIds.map((object) => this.create(object)));
      return order.map((condition) => {
        if (condition) {
          return recordsWithId.shift();
        } else {
          return recordsWithoutId.shift();
        }
      }).filter((record) => !!record);
    }
    if (isString(a) && isObject(b)) {
      if (a === "")
        throw new Error("The id can't be empty");
      const record = await __privateMethod$2(this, _insertRecordWithId, insertRecordWithId_fn).call(this, a, b);
      await __privateMethod$2(this, _setCacheRecord, setCacheRecord_fn).call(this, record);
      return record;
    }
    if (isObject(a) && isString(a.id)) {
      if (a.id === "")
        throw new Error("The id can't be empty");
      const record = await __privateMethod$2(this, _insertRecordWithId, insertRecordWithId_fn).call(this, a.id, { ...a, id: void 0 });
      await __privateMethod$2(this, _setCacheRecord, setCacheRecord_fn).call(this, record);
      return record;
    }
    if (isObject(a)) {
      const record = await __privateMethod$2(this, _insertRecordWithoutId, insertRecordWithoutId_fn).call(this, a);
      await __privateMethod$2(this, _setCacheRecord, setCacheRecord_fn).call(this, record);
      return record;
    }
    throw new Error("Invalid arguments for create method");
  }
  async read(a) {
    if (Array.isArray(a)) {
      if (a.length === 0)
        return [];
      const ids = a.map((item) => isString(item) ? item : item.id).filter((id2) => isString(id2));
      return this.getAll({ filter: { id: { $any: ids } } });
    }
    const id = isString(a) ? a : a.id;
    if (isString(id)) {
      const cacheRecord = await __privateMethod$2(this, _getCacheRecord, getCacheRecord_fn).call(this, id);
      if (cacheRecord)
        return cacheRecord;
      const fetchProps = await __privateGet$4(this, _getFetchProps).call(this);
      try {
        const response = await getRecord({
          pathParams: { workspace: "{workspaceId}", dbBranchName: "{dbBranch}", tableName: __privateGet$4(this, _table), recordId: id },
          ...fetchProps
        });
        const schema = await __privateMethod$2(this, _getSchema$1, getSchema_fn$1).call(this);
        return initObject(this.db, schema, __privateGet$4(this, _table), response);
      } catch (e) {
        if (isObject(e) && e.status === 404) {
          return null;
        }
        throw e;
      }
    }
  }
  async update(a, b) {
    if (Array.isArray(a)) {
      if (a.length === 0)
        return [];
      if (a.length > 100) {
        console.warn("Bulk update operation is not optimized in the Xata API yet, this request might be slow");
      }
      return Promise.all(a.map((object) => this.update(object)));
    }
    if (isString(a) && isObject(b)) {
      await __privateMethod$2(this, _invalidateCache, invalidateCache_fn).call(this, a);
      const record = await __privateMethod$2(this, _updateRecordWithID, updateRecordWithID_fn).call(this, a, b);
      await __privateMethod$2(this, _setCacheRecord, setCacheRecord_fn).call(this, record);
      return record;
    }
    if (isObject(a) && isString(a.id)) {
      await __privateMethod$2(this, _invalidateCache, invalidateCache_fn).call(this, a.id);
      const record = await __privateMethod$2(this, _updateRecordWithID, updateRecordWithID_fn).call(this, a.id, { ...a, id: void 0 });
      await __privateMethod$2(this, _setCacheRecord, setCacheRecord_fn).call(this, record);
      return record;
    }
    throw new Error("Invalid arguments for update method");
  }
  async createOrUpdate(a, b) {
    if (Array.isArray(a)) {
      if (a.length === 0)
        return [];
      if (a.length > 100) {
        console.warn("Bulk update operation is not optimized in the Xata API yet, this request might be slow");
      }
      return Promise.all(a.map((object) => this.createOrUpdate(object)));
    }
    if (isString(a) && isObject(b)) {
      await __privateMethod$2(this, _invalidateCache, invalidateCache_fn).call(this, a);
      const record = await __privateMethod$2(this, _upsertRecordWithID, upsertRecordWithID_fn).call(this, a, b);
      await __privateMethod$2(this, _setCacheRecord, setCacheRecord_fn).call(this, record);
      return record;
    }
    if (isObject(a) && isString(a.id)) {
      await __privateMethod$2(this, _invalidateCache, invalidateCache_fn).call(this, a.id);
      const record = await __privateMethod$2(this, _upsertRecordWithID, upsertRecordWithID_fn).call(this, a.id, { ...a, id: void 0 });
      await __privateMethod$2(this, _setCacheRecord, setCacheRecord_fn).call(this, record);
      return record;
    }
    throw new Error("Invalid arguments for createOrUpdate method");
  }
  async delete(a) {
    if (Array.isArray(a)) {
      if (a.length === 0)
        return;
      if (a.length > 100) {
        console.warn("Bulk delete operation is not optimized in the Xata API yet, this request might be slow");
      }
      await Promise.all(a.map((id) => this.delete(id)));
      return;
    }
    if (isString(a)) {
      await __privateMethod$2(this, _deleteRecord, deleteRecord_fn).call(this, a);
      await __privateMethod$2(this, _invalidateCache, invalidateCache_fn).call(this, a);
      return;
    }
    if (isObject(a) && isString(a.id)) {
      await __privateMethod$2(this, _deleteRecord, deleteRecord_fn).call(this, a.id);
      await __privateMethod$2(this, _invalidateCache, invalidateCache_fn).call(this, a.id);
      return;
    }
    throw new Error("Invalid arguments for delete method");
  }
  async search(query, options = {}) {
    const fetchProps = await __privateGet$4(this, _getFetchProps).call(this);
    const { records } = await searchTable({
      pathParams: { workspace: "{workspaceId}", dbBranchName: "{dbBranch}", tableName: __privateGet$4(this, _table) },
      body: {
        query,
        fuzziness: options.fuzziness,
        highlight: options.highlight,
        filter: options.filter
      },
      ...fetchProps
    });
    const schema = await __privateMethod$2(this, _getSchema$1, getSchema_fn$1).call(this);
    return records.map((item) => initObject(this.db, schema, __privateGet$4(this, _table), item));
  }
  async query(query) {
    const cacheQuery = await __privateMethod$2(this, _getCacheQuery, getCacheQuery_fn).call(this, query);
    if (cacheQuery)
      return new Page(query, cacheQuery.meta, cacheQuery.records);
    const data = query.getQueryOptions();
    const body = {
      filter: Object.values(data.filter ?? {}).some(Boolean) ? data.filter : void 0,
      sort: data.sort !== void 0 ? buildSortFilter(data.sort) : void 0,
      page: data.pagination,
      columns: data.columns
    };
    const fetchProps = await __privateGet$4(this, _getFetchProps).call(this);
    const { meta, records: objects } = await queryTable({
      pathParams: { workspace: "{workspaceId}", dbBranchName: "{dbBranch}", tableName: __privateGet$4(this, _table) },
      body,
      ...fetchProps
    });
    const schema = await __privateMethod$2(this, _getSchema$1, getSchema_fn$1).call(this);
    const records = objects.map((record) => initObject(this.db, schema, __privateGet$4(this, _table), record));
    await __privateMethod$2(this, _setCacheQuery, setCacheQuery_fn).call(this, query, meta, records);
    return new Page(query, meta, records);
  }
}
_table = new WeakMap();
_getFetchProps = new WeakMap();
_cache = new WeakMap();
_schema$1 = new WeakMap();
_insertRecordWithoutId = new WeakSet();
insertRecordWithoutId_fn = async function(object) {
  const fetchProps = await __privateGet$4(this, _getFetchProps).call(this);
  const record = transformObjectLinks(object);
  const response = await insertRecord({
    pathParams: {
      workspace: "{workspaceId}",
      dbBranchName: "{dbBranch}",
      tableName: __privateGet$4(this, _table)
    },
    body: record,
    ...fetchProps
  });
  const finalObject = await this.read(response.id);
  if (!finalObject) {
    throw new Error("The server failed to save the record");
  }
  return finalObject;
};
_insertRecordWithId = new WeakSet();
insertRecordWithId_fn = async function(recordId, object) {
  const fetchProps = await __privateGet$4(this, _getFetchProps).call(this);
  const record = transformObjectLinks(object);
  const response = await insertRecordWithID({
    pathParams: {
      workspace: "{workspaceId}",
      dbBranchName: "{dbBranch}",
      tableName: __privateGet$4(this, _table),
      recordId
    },
    body: record,
    queryParams: { createOnly: true },
    ...fetchProps
  });
  const finalObject = await this.read(response.id);
  if (!finalObject) {
    throw new Error("The server failed to save the record");
  }
  return finalObject;
};
_bulkInsertTableRecords = new WeakSet();
bulkInsertTableRecords_fn = async function(objects) {
  const fetchProps = await __privateGet$4(this, _getFetchProps).call(this);
  const records = objects.map((object) => transformObjectLinks(object));
  const response = await bulkInsertTableRecords({
    pathParams: { workspace: "{workspaceId}", dbBranchName: "{dbBranch}", tableName: __privateGet$4(this, _table) },
    body: { records },
    ...fetchProps
  });
  const finalObjects = await this.read(response.recordIDs);
  if (finalObjects.length !== objects.length) {
    throw new Error("The server failed to save some records");
  }
  return finalObjects;
};
_updateRecordWithID = new WeakSet();
updateRecordWithID_fn = async function(recordId, object) {
  const fetchProps = await __privateGet$4(this, _getFetchProps).call(this);
  const record = transformObjectLinks(object);
  const response = await updateRecordWithID({
    pathParams: { workspace: "{workspaceId}", dbBranchName: "{dbBranch}", tableName: __privateGet$4(this, _table), recordId },
    body: record,
    ...fetchProps
  });
  const item = await this.read(response.id);
  if (!item)
    throw new Error("The server failed to save the record");
  return item;
};
_upsertRecordWithID = new WeakSet();
upsertRecordWithID_fn = async function(recordId, object) {
  const fetchProps = await __privateGet$4(this, _getFetchProps).call(this);
  const response = await upsertRecordWithID({
    pathParams: { workspace: "{workspaceId}", dbBranchName: "{dbBranch}", tableName: __privateGet$4(this, _table), recordId },
    body: object,
    ...fetchProps
  });
  const item = await this.read(response.id);
  if (!item)
    throw new Error("The server failed to save the record");
  return item;
};
_deleteRecord = new WeakSet();
deleteRecord_fn = async function(recordId) {
  const fetchProps = await __privateGet$4(this, _getFetchProps).call(this);
  await deleteRecord({
    pathParams: { workspace: "{workspaceId}", dbBranchName: "{dbBranch}", tableName: __privateGet$4(this, _table), recordId },
    ...fetchProps
  });
};
_invalidateCache = new WeakSet();
invalidateCache_fn = async function(recordId) {
  await __privateGet$4(this, _cache).delete(`rec_${__privateGet$4(this, _table)}:${recordId}`);
  const cacheItems = await __privateGet$4(this, _cache).getAll();
  const queries = Object.entries(cacheItems).filter(([key]) => key.startsWith("query_"));
  for (const [key, value] of queries) {
    const ids = getIds(value);
    if (ids.includes(recordId))
      await __privateGet$4(this, _cache).delete(key);
  }
};
_setCacheRecord = new WeakSet();
setCacheRecord_fn = async function(record) {
  if (!__privateGet$4(this, _cache).cacheRecords)
    return;
  await __privateGet$4(this, _cache).set(`rec_${__privateGet$4(this, _table)}:${record.id}`, record);
};
_getCacheRecord = new WeakSet();
getCacheRecord_fn = async function(recordId) {
  if (!__privateGet$4(this, _cache).cacheRecords)
    return null;
  return __privateGet$4(this, _cache).get(`rec_${__privateGet$4(this, _table)}:${recordId}`);
};
_setCacheQuery = new WeakSet();
setCacheQuery_fn = async function(query, meta, records) {
  await __privateGet$4(this, _cache).set(`query_${__privateGet$4(this, _table)}:${query.key()}`, { date: new Date(), meta, records });
};
_getCacheQuery = new WeakSet();
getCacheQuery_fn = async function(query) {
  const key = `query_${__privateGet$4(this, _table)}:${query.key()}`;
  const result = await __privateGet$4(this, _cache).get(key);
  if (!result)
    return null;
  const { cache: ttl = __privateGet$4(this, _cache).defaultQueryTTL } = query.getQueryOptions();
  if (ttl < 0)
    return null;
  const hasExpired = result.date.getTime() + ttl < Date.now();
  return hasExpired ? null : result;
};
_getSchema$1 = new WeakSet();
getSchema_fn$1 = async function() {
  if (__privateGet$4(this, _schema$1))
    return __privateGet$4(this, _schema$1);
  const fetchProps = await __privateGet$4(this, _getFetchProps).call(this);
  const { schema } = await getBranchDetails({
    pathParams: { workspace: "{workspaceId}", dbBranchName: "{dbBranch}" },
    ...fetchProps
  });
  __privateSet$3(this, _schema$1, schema);
  return schema;
};
const transformObjectLinks = (object) => {
  return Object.entries(object).reduce((acc, [key, value]) => {
    if (key === "xata")
      return acc;
    return { ...acc, [key]: isIdentifiable(value) ? value.id : value };
  }, {});
};
const initObject = (db, schema, table, object) => {
  const result = {};
  const { xata, ...rest } = object ?? {};
  Object.assign(result, rest);
  const { columns } = schema.tables.find(({ name }) => name === table) ?? {};
  if (!columns)
    console.error(`Table ${table} not found in schema`);
  for (const column of columns ?? []) {
    const value = result[column.name];
    switch (column.type) {
      case "datetime": {
        const date = value !== void 0 ? new Date(value) : void 0;
        if (date && isNaN(date.getTime())) {
          console.error(`Failed to parse date ${value} for field ${column.name}`);
        } else if (date) {
          result[column.name] = date;
        }
        break;
      }
      case "link": {
        const linkTable = column.link?.table;
        if (!linkTable) {
          console.error(`Failed to parse link for field ${column.name}`);
        } else if (isObject(value)) {
          result[column.name] = initObject(db, schema, linkTable, value);
        }
        break;
      }
    }
  }
  result.read = function() {
    return db[table].read(result["id"]);
  };
  result.update = function(data) {
    return db[table].update(result["id"], data);
  };
  result.delete = function() {
    return db[table].delete(result["id"]);
  };
  result.getMetadata = function() {
    return xata;
  };
  for (const prop of ["read", "update", "delete", "getMetadata"]) {
    Object.defineProperty(result, prop, { enumerable: false });
  }
  Object.freeze(result);
  return result;
};
function getIds(value) {
  if (Array.isArray(value)) {
    return value.map((item) => getIds(item)).flat();
  }
  if (!isObject(value))
    return [];
  const nestedIds = Object.values(value).map((item) => getIds(item)).flat();
  return isString(value.id) ? [value.id, ...nestedIds] : nestedIds;
}

var __accessCheck$3 = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet$3 = (obj, member, getter) => {
  __accessCheck$3(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd$3 = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet$2 = (obj, member, value, setter) => {
  __accessCheck$3(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
var _map;
class SimpleCache {
  constructor(options = {}) {
    __privateAdd$3(this, _map, void 0);
    __privateSet$2(this, _map, /* @__PURE__ */ new Map());
    this.capacity = options.max ?? 500;
    this.cacheRecords = options.cacheRecords ?? true;
    this.defaultQueryTTL = options.defaultQueryTTL ?? 60 * 1e3;
  }
  async getAll() {
    return Object.fromEntries(__privateGet$3(this, _map));
  }
  async get(key) {
    return __privateGet$3(this, _map).get(key) ?? null;
  }
  async set(key, value) {
    await this.delete(key);
    __privateGet$3(this, _map).set(key, value);
    if (__privateGet$3(this, _map).size > this.capacity) {
      const leastRecentlyUsed = __privateGet$3(this, _map).keys().next().value;
      await this.delete(leastRecentlyUsed);
    }
  }
  async delete(key) {
    __privateGet$3(this, _map).delete(key);
  }
  async clear() {
    return __privateGet$3(this, _map).clear();
  }
}
_map = new WeakMap();

const gt = (value) => ({ $gt: value });
const ge = (value) => ({ $ge: value });
const gte = (value) => ({ $ge: value });
const lt = (value) => ({ $lt: value });
const lte = (value) => ({ $le: value });
const le = (value) => ({ $le: value });
const exists = (column) => ({ $exists: column });
const notExists = (column) => ({ $notExists: column });
const startsWith = (value) => ({ $startsWith: value });
const endsWith = (value) => ({ $endsWith: value });
const pattern = (value) => ({ $pattern: value });
const is = (value) => ({ $is: value });
const isNot = (value) => ({ $isNot: value });
const contains = (value) => ({ $contains: value });
const includes = (value) => ({ $includes: value });
const includesAll = (value) => ({ $includesAll: value });
const includesNone = (value) => ({ $includesNone: value });
const includesAny = (value) => ({ $includesAny: value });

var __accessCheck$2 = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet$2 = (obj, member, getter) => {
  __accessCheck$2(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd$2 = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var _tables;
class SchemaPlugin extends XataPlugin {
  constructor(tableNames) {
    super();
    this.tableNames = tableNames;
    __privateAdd$2(this, _tables, {});
  }
  build(pluginOptions) {
    const db = new Proxy({}, {
      get: (_target, table) => {
        if (!isString(table))
          throw new Error("Invalid table name");
        if (__privateGet$2(this, _tables)[table] === void 0) {
          __privateGet$2(this, _tables)[table] = new RestRepository({ db, pluginOptions, table });
        }
        return __privateGet$2(this, _tables)[table];
      }
    });
    for (const table of this.tableNames ?? []) {
      db[table] = new RestRepository({ db, pluginOptions, table });
    }
    return db;
  }
}
_tables = new WeakMap();

var __accessCheck$1 = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet$1 = (obj, member, getter) => {
  __accessCheck$1(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd$1 = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet$1 = (obj, member, value, setter) => {
  __accessCheck$1(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
var __privateMethod$1 = (obj, member, method) => {
  __accessCheck$1(obj, member, "access private method");
  return method;
};
var _schema, _search, search_fn, _getSchema, getSchema_fn;
class SearchPlugin extends XataPlugin {
  constructor(db) {
    super();
    this.db = db;
    __privateAdd$1(this, _search);
    __privateAdd$1(this, _getSchema);
    __privateAdd$1(this, _schema, void 0);
  }
  build({ getFetchProps }) {
    return {
      all: async (query, options = {}) => {
        const records = await __privateMethod$1(this, _search, search_fn).call(this, query, options, getFetchProps);
        const schema = await __privateMethod$1(this, _getSchema, getSchema_fn).call(this, getFetchProps);
        return records.map((record) => {
          const { table = "orphan" } = record.xata;
          return { table, record: initObject(this.db, schema, table, record) };
        });
      },
      byTable: async (query, options = {}) => {
        const records = await __privateMethod$1(this, _search, search_fn).call(this, query, options, getFetchProps);
        const schema = await __privateMethod$1(this, _getSchema, getSchema_fn).call(this, getFetchProps);
        return records.reduce((acc, record) => {
          const { table = "orphan" } = record.xata;
          const items = acc[table] ?? [];
          const item = initObject(this.db, schema, table, record);
          return { ...acc, [table]: [...items, item] };
        }, {});
      }
    };
  }
}
_schema = new WeakMap();
_search = new WeakSet();
search_fn = async function(query, options, getFetchProps) {
  const fetchProps = await getFetchProps();
  const { tables, fuzziness, highlight } = options ?? {};
  const { records } = await searchBranch({
    pathParams: { workspace: "{workspaceId}", dbBranchName: "{dbBranch}" },
    body: { tables, query, fuzziness, highlight },
    ...fetchProps
  });
  return records;
};
_getSchema = new WeakSet();
getSchema_fn = async function(getFetchProps) {
  if (__privateGet$1(this, _schema))
    return __privateGet$1(this, _schema);
  const fetchProps = await getFetchProps();
  const { schema } = await getBranchDetails({
    pathParams: { workspace: "{workspaceId}", dbBranchName: "{dbBranch}" },
    ...fetchProps
  });
  __privateSet$1(this, _schema, schema);
  return schema;
};

const isBranchStrategyBuilder = (strategy) => {
  return typeof strategy === "function";
};

const envBranchNames = [
  "XATA_BRANCH",
  "VERCEL_GIT_COMMIT_REF",
  "CF_PAGES_BRANCH",
  "BRANCH"
];
async function getCurrentBranchName(options) {
  const env = getBranchByEnvVariable();
  if (env) {
    const details = await getDatabaseBranch(env, options);
    if (details)
      return env;
    console.warn(`Branch ${env} not found in Xata. Ignoring...`);
  }
  const gitBranch = await getGitBranch();
  return resolveXataBranch(gitBranch, options);
}
async function getCurrentBranchDetails(options) {
  const branch = await getCurrentBranchName(options);
  return getDatabaseBranch(branch, options);
}
async function resolveXataBranch(gitBranch, options) {
  const databaseURL = options?.databaseURL || getDatabaseURL();
  const apiKey = options?.apiKey || getAPIKey();
  if (!databaseURL)
    throw new Error("A databaseURL was not defined. Either set the XATA_DATABASE_URL env variable or pass the argument explicitely");
  if (!apiKey)
    throw new Error("An API key was not defined. Either set the XATA_API_KEY env variable or pass the argument explicitely");
  const [protocol, , host, , dbName] = databaseURL.split("/");
  const [workspace] = host.split(".");
  const { branch } = await resolveBranch({
    apiKey,
    apiUrl: databaseURL,
    fetchImpl: getFetchImplementation(options?.fetchImpl),
    workspacesApiUrl: `${protocol}//${host}`,
    pathParams: { dbName, workspace },
    queryParams: { gitBranch, fallbackBranch: getEnvVariable("XATA_FALLBACK_BRANCH") }
  });
  return branch;
}
async function getDatabaseBranch(branch, options) {
  const databaseURL = options?.databaseURL || getDatabaseURL();
  const apiKey = options?.apiKey || getAPIKey();
  if (!databaseURL)
    throw new Error("A databaseURL was not defined. Either set the XATA_DATABASE_URL env variable or pass the argument explicitely");
  if (!apiKey)
    throw new Error("An API key was not defined. Either set the XATA_API_KEY env variable or pass the argument explicitely");
  const [protocol, , host, , database] = databaseURL.split("/");
  const [workspace] = host.split(".");
  const dbBranchName = `${database}:${branch}`;
  try {
    return await getBranchDetails({
      apiKey,
      apiUrl: databaseURL,
      fetchImpl: getFetchImplementation(options?.fetchImpl),
      workspacesApiUrl: `${protocol}//${host}`,
      pathParams: { dbBranchName, workspace }
    });
  } catch (err) {
    if (isObject(err) && err.status === 404)
      return null;
    throw err;
  }
}
function getBranchByEnvVariable() {
  for (const name of envBranchNames) {
    const value = getEnvVariable(name);
    if (value) {
      return value;
    }
  }
  try {
    return XATA_BRANCH;
  } catch (err) {
  }
}
function getDatabaseURL() {
  try {
    return getEnvVariable("XATA_DATABASE_URL") ?? XATA_DATABASE_URL;
  } catch (err) {
    return void 0;
  }
}

var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet = (obj, member, value, setter) => {
  __accessCheck(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
var __privateMethod = (obj, member, method) => {
  __accessCheck(obj, member, "access private method");
  return method;
};
const buildClient = (plugins) => {
  var _branch, _parseOptions, parseOptions_fn, _getFetchProps, getFetchProps_fn, _evaluateBranch, evaluateBranch_fn, _a;
  return _a = class {
    constructor(options = {}, tables) {
      __privateAdd(this, _parseOptions);
      __privateAdd(this, _getFetchProps);
      __privateAdd(this, _evaluateBranch);
      __privateAdd(this, _branch, void 0);
      const safeOptions = __privateMethod(this, _parseOptions, parseOptions_fn).call(this, options);
      const pluginOptions = {
        getFetchProps: () => __privateMethod(this, _getFetchProps, getFetchProps_fn).call(this, safeOptions),
        cache: safeOptions.cache
      };
      const db = new SchemaPlugin(tables).build(pluginOptions);
      const search = new SearchPlugin(db).build(pluginOptions);
      this.db = db;
      this.search = search;
      for (const [key, namespace] of Object.entries(plugins ?? {})) {
        if (namespace === void 0)
          continue;
        const result = namespace.build(pluginOptions);
        if (result instanceof Promise) {
          void result.then((namespace2) => {
            this[key] = namespace2;
          });
        } else {
          this[key] = result;
        }
      }
    }
  }, _branch = new WeakMap(), _parseOptions = new WeakSet(), parseOptions_fn = function(options) {
    const fetch = getFetchImplementation(options?.fetch);
    const databaseURL = options?.databaseURL || getDatabaseURL();
    const apiKey = options?.apiKey || getAPIKey();
    const cache = options?.cache ?? new SimpleCache({ cacheRecords: false, defaultQueryTTL: 0 });
    const branch = async () => options?.branch !== void 0 ? await __privateMethod(this, _evaluateBranch, evaluateBranch_fn).call(this, options.branch) : await getCurrentBranchName({ apiKey, databaseURL, fetchImpl: options?.fetch });
    if (!databaseURL || !apiKey) {
      throw new Error("Options databaseURL and apiKey are required");
    }
    return { fetch, databaseURL, apiKey, branch, cache };
  }, _getFetchProps = new WeakSet(), getFetchProps_fn = async function({
    fetch,
    apiKey,
    databaseURL,
    branch
  }) {
    const branchValue = await __privateMethod(this, _evaluateBranch, evaluateBranch_fn).call(this, branch);
    if (!branchValue)
      throw new Error("Unable to resolve branch value");
    return {
      fetchImpl: fetch,
      apiKey,
      apiUrl: "",
      workspacesApiUrl: (path, params) => {
        const hasBranch = params.dbBranchName ?? params.branch;
        const newPath = path.replace(/^\/db\/[^/]+/, hasBranch ? `:${branchValue}` : "");
        return databaseURL + newPath;
      }
    };
  }, _evaluateBranch = new WeakSet(), evaluateBranch_fn = async function(param) {
    if (__privateGet(this, _branch))
      return __privateGet(this, _branch);
    if (param === void 0)
      return void 0;
    const strategies = Array.isArray(param) ? [...param] : [param];
    const evaluateBranch = async (strategy) => {
      return isBranchStrategyBuilder(strategy) ? await strategy() : strategy;
    };
    for await (const strategy of strategies) {
      const branch = await evaluateBranch(strategy);
      if (branch) {
        __privateSet(this, _branch, branch);
        return branch;
      }
    }
  }, _a;
};
class BaseClient extends buildClient() {
}

class XataError extends Error {
  constructor(message, status) {
    super(message);
    this.status = status;
  }
}

export { BaseClient, operationsByTag as Operations, PAGINATION_DEFAULT_OFFSET, PAGINATION_DEFAULT_SIZE, PAGINATION_MAX_OFFSET, PAGINATION_MAX_SIZE, Page, Query, RecordArray, Repository, RestRepository, SchemaPlugin, SearchPlugin, SimpleCache, XataApiClient, XataApiPlugin, XataError, XataPlugin, acceptWorkspaceMemberInvite, addGitBranchesEntry, addTableColumn, buildClient, bulkInsertTableRecords, cancelWorkspaceMemberInvite, contains, createBranch, createDatabase, createTable, createUserAPIKey, createWorkspace, deleteBranch, deleteColumn, deleteDatabase, deleteRecord, deleteTable, deleteUser, deleteUserAPIKey, deleteWorkspace, endsWith, executeBranchMigrationPlan, exists, ge, getAPIKey, getBranchDetails, getBranchList, getBranchMetadata, getBranchMigrationHistory, getBranchMigrationPlan, getBranchStats, getColumn, getCurrentBranchDetails, getCurrentBranchName, getDatabaseList, getDatabaseURL, getGitBranchesMapping, getRecord, getTableColumns, getTableSchema, getUser, getUserAPIKeys, getWorkspace, getWorkspaceMembersList, getWorkspacesList, gt, gte, includes, includesAll, includesAny, includesNone, insertRecord, insertRecordWithID, inviteWorkspaceMember, is, isCursorPaginationOptions, isIdentifiable, isNot, isXataRecord, le, lt, lte, notExists, operationsByTag, pattern, queryTable, removeGitBranchesEntry, removeWorkspaceMember, resendWorkspaceMemberInvite, resolveBranch, searchBranch, searchTable, setTableSchema, startsWith, updateBranchMetadata, updateColumn, updateRecordWithID, updateTable, updateUser, updateWorkspace, updateWorkspaceMemberRole, upsertRecordWithID };
//# sourceMappingURL=index.mjs.map
