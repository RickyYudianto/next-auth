// src/npm2pnpm.ts
var unchangedCLICommands = ["init", "run", "test", "login", "logout", "link", "publish", "cache"];
function parseNpmInstall(command, isShortHand = false) {
  if (/^install *$/.test(command)) {
    return "install";
  }
  return command.replace(isShortHand ? "i " : "install ", "add ").replace(/(\s*)--save(?!-)/, "$1--save-prod").replace("--no-package-lock", "");
}
var npmToPnpmTable = {
  install(command) {
    return parseNpmInstall(command);
  },
  i(command) {
    return parseNpmInstall(command, true);
  },
  uninstall(command) {
    return command.replace("uninstall", "remove").replace(/(\s*)--save(?!-)/, "$1--save-prod").replace("--no-package-lock", "");
  },
  version(command) {
    return command.replace(/(major|minor|patch)/, "--$1");
  },
  rebuild(command) {
    return command.replace("rebuild", "add --force");
  }
};
function convert(_, command) {
  command = (command ?? "").trim();
  const firstCommand = (/\w+/.exec(command) || [""])[0];
  if (unchangedCLICommands.includes(firstCommand)) {
    return `pnpm ${command}`;
  } else if (Object.prototype.hasOwnProperty.call(npmToPnpmTable, firstCommand) && npmToPnpmTable[firstCommand]) {
    if (typeof npmToPnpmTable[firstCommand] === "function") {
      return `pnpm ${npmToPnpmTable[firstCommand](command)}`;
    }
    return `pnpm ${command.replace(firstCommand, npmToPnpmTable[firstCommand])}`;
  }
  return `pnpm ${command}
# couldn't auto-convert command`;
}
function npmToPnpm(str) {
  return str.replace(/npm(?: +([^&\n\r]*))?/gm, convert);
}

// src/npm2yarn.ts
var unchangedCLICommands2 = ["test", "login", "logout", "link", "publish", "cache"];
var yarnCLICommands = [
  "init",
  "run",
  "add",
  "audit",
  "autoclean",
  "bin",
  "check",
  "config",
  "create",
  "dedupe",
  "generate-lock-entry",
  "global",
  "help",
  "import",
  "info",
  "install",
  "licenses",
  "list",
  "lockfile",
  "outdated",
  "owner",
  "pack",
  "policies",
  "prune",
  "remove",
  "self-update",
  "tag",
  "team",
  "link",
  "unlink",
  "upgrade",
  "upgrade-interactive",
  "version",
  "versions",
  "why",
  "workspace",
  "workspaces"
];
function parseNpmInstall2(command, isShortHand = false) {
  if (/^install *$/.test(command)) {
    return "install";
  }
  let yarnAddCommand = command.replace(isShortHand ? "i " : "install ", "add ").replace("--save-dev", "--dev").replace(/\s*--save(?!-)/, "").replace("--no-package-lock", "--no-lockfile").replace("--save-optional", "--optional").replace("--save-exact", "--exact");
  if (/ -(?:-global|g)(?![^\b])/.test(yarnAddCommand)) {
    yarnAddCommand = yarnAddCommand.replace(/ -(?:-global|g)(?![^\b])/, "");
    yarnAddCommand = `global ${yarnAddCommand}`;
  }
  return yarnAddCommand;
}
var npmToYarnTable = {
  install(command) {
    return parseNpmInstall2(command);
  },
  i(command) {
    return parseNpmInstall2(command, true);
  },
  uninstall(command) {
    let yarnRemoveCommand = command.replace("uninstall", "remove").replace("--save-dev", "--dev").replace(/\s*--save(?!-)/, "").replace("--no-package-lock", "--no-lockfile");
    if (/ -(?:-global|g)(?![^\b])/.test(yarnRemoveCommand)) {
      yarnRemoveCommand = yarnRemoveCommand.replace(/ -(?:-global|g)(?![^\b])/, "");
      yarnRemoveCommand = `global ${yarnRemoveCommand}`;
    }
    return yarnRemoveCommand;
  },
  rebuild(command) {
    return command.replace("rebuild", "add --force");
  },
  exec(command) {
    return command.replace(/^exec\s?([^\s]+)?(\s--\s--)?(.*)$/, (_, data, dash, rest) => {
      let result = "";
      if (data && !unchangedCLICommands2.includes(data) && !yarnCLICommands.includes(data)) {
        result += data;
      } else {
        result += `run ${data || ""}`;
      }
      if (dash) {
        result += dash.replace(/^\s--/, "");
      }
      if (rest) {
        result += rest;
      }
      return result;
    });
  },
  run(command) {
    return command.replace(/^run\s?([^\s]+)?(\s--\s--)?(.*)$/, (_, data, dash, rest) => {
      let result = "";
      if (data && !unchangedCLICommands2.includes(data) && !yarnCLICommands.includes(data)) {
        result += data;
      } else {
        result += `run ${data || ""}`;
      }
      if (dash) {
        result += dash.replace(/^\s--/, "");
      }
      if (rest) {
        result += rest;
      }
      return result;
    });
  },
  ls(command) {
    return command.replace(/^(ls|list)(.*)$/, (_1, _2, args) => {
      let result = "list";
      if (args) {
        let ended = false;
        let packages = [];
        const items = args.split(" ").filter(Boolean);
        for (const item of items) {
          if (ended) {
            result += ` ${item}`;
          } else if (item.startsWith("-")) {
            result += ` --pattern "${packages.join("|")}"`;
            packages = [];
            ended = true;
            result += ` ${item}`;
          } else {
            packages.push(item);
          }
        }
        if (packages.length > 0) {
          result += ` --pattern "${packages.join("|")}"`;
        }
        return result;
      }
      return "list";
    });
  },
  list(command) {
    return npmToYarnTable.ls(command);
  },
  init(command) {
    if (/^init (?!-).*$/.test(command)) {
      return command.replace("init", "create");
    }
    return command.replace(" --scope", "");
  }
};
function convert2(_, command) {
  command = (command || "").trim();
  const firstCommand = (/\w+/.exec(command) || [""])[0];
  if (unchangedCLICommands2.includes(firstCommand)) {
    return `yarn ${command}`;
  }
  if (firstCommand in npmToYarnTable) {
    const converter = npmToYarnTable[firstCommand];
    if (typeof converter === "function") {
      return `yarn ${converter(command)}`;
    }
    return `yarn ${command.replace(firstCommand, converter)}`;
  }
  return `yarn ${command}
# couldn't auto-convert command`;
}
function npmToYarn(str) {
  return str.replace(/npm(?: +([^&\n\r]*))?/gm, convert2);
}

// src/npm2yarn2pnpm.ts
import visit from "unist-util-visit";
var transformNode = (node, options) => {
  const groupIdProp = options.sync ? ' groupId="npm2yarn2pnpm"' : "";
  const npmCode = node.value;
  const yarnCode = npmToYarn(node.value);
  const pnpmCode = npmToPnpm(node.value);
  const [, highlight] = (node.meta ?? "").split("|");
  return [
    {
      type: "jsx",
      value: `<Tabs${groupIdProp}
						defaultValue="npm"
						values={[
							{ label: "npm", value: "npm" },
							{ label: "yarn", value: "yarn" },
							{ label: "pnpm", value: "pnpm" },
						]}
			>
<TabItem value="npm">`
    },
    {
      type: node.type,
      lang: node.lang,
      meta: `${highlight} showLineNumbers`,
      value: npmCode
    },
    {
      type: "jsx",
      value: '</TabItem>\n<TabItem value="yarn" label="Yarn">'
    },
    {
      type: node.type,
      lang: node.lang,
      meta: `${highlight} showLineNumbers`,
      value: yarnCode
    },
    {
      type: "jsx",
      value: '</TabItem>\n<TabItem value="pnpm">'
    },
    {
      type: node.type,
      lang: node.lang,
      meta: `${highlight} showLineNumbers`,
      value: pnpmCode
    },
    {
      type: "jsx",
      value: "</TabItem>\n</Tabs>"
    }
  ];
};
var isImport = (node) => node.type === "import";
var isParent = (node) => Array.isArray(node.children);
var matchNode = (node) => node.type === "code" && typeof node.meta === "string" && (node.meta ?? "").startsWith("npm2yarn2pnpm");
var nodeForImport = {
  type: "import",
  value: "import Tabs from '@theme/Tabs';\nimport TabItem from '@theme/TabItem';"
};
var npm2yarn2pnpm = ({ sync = true } = { sync: true }) => (root) => {
  let transformed = false;
  let alreadyImported = false;
  visit(root, (node) => {
    if (isImport(node) && node.value.includes("@theme/Tabs")) {
      alreadyImported = true;
    }
    if (isParent(node)) {
      let index = 0;
      while (index < node.children.length) {
        const child = node.children[index];
        if (matchNode(child)) {
          const result = transformNode(child, { sync });
          node.children.splice(index, 1, ...result);
          index += result.length;
          transformed = true;
        } else {
          index += 1;
        }
      }
    }
  });
  if (transformed && !alreadyImported) {
    root.children.unshift(nodeForImport);
  }
};
export {
  npm2yarn2pnpm,
  npmToPnpm,
  npmToYarn
};
//# sourceMappingURL=index.mjs.map