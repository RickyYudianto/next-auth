declare type FetchImpl = (url: string, init?: {
    body?: string;
    headers?: Record<string, string>;
    method?: string;
}) => Promise<{
    ok: boolean;
    status: number;
    json(): Promise<any>;
    headers?: {
        get(name: string): string | null;
    };
}>;
declare type WorkspaceApiUrlBuilder = (path: string, pathParams: Record<string, string>) => string;
declare type FetcherExtraProps = {
    apiUrl: string;
    workspacesApiUrl: string | WorkspaceApiUrlBuilder;
    fetchImpl: FetchImpl;
    apiKey: string;
};
declare type ErrorWrapper<TError> = TError | {
    status: 'unknown';
    payload: string;
};

interface CacheImpl {
    cacheRecords: boolean;
    defaultQueryTTL: number;
    getAll(): Promise<Record<string, unknown>>;
    get: <T>(key: string) => Promise<T | null>;
    set: <T>(key: string, value: T) => Promise<void>;
    delete: (key: string) => Promise<void>;
    clear: () => Promise<void>;
}
interface SimpleCacheOptions {
    max?: number;
    cacheRecords?: boolean;
    defaultQueryTTL?: number;
}
declare class SimpleCache implements CacheImpl {
    #private;
    capacity: number;
    cacheRecords: boolean;
    defaultQueryTTL: number;
    constructor(options?: SimpleCacheOptions);
    getAll(): Promise<Record<string, unknown>>;
    get<T>(key: string): Promise<T | null>;
    set<T>(key: string, value: T): Promise<void>;
    delete(key: string): Promise<void>;
    clear(): Promise<void>;
}

declare abstract class XataPlugin {
    abstract build(options: XataPluginOptions): unknown | Promise<unknown>;
}
declare type XataPluginOptions = {
    getFetchProps: () => Promise<FetcherExtraProps>;
    cache: CacheImpl;
};

/**
 * Generated by @openapi-codegen
 *
 * @version 1.0
 */
declare type User = {
    email: string;
    fullname: string;
    image: string;
};
/**
 * @pattern [a-zA-Z0-9_-~:]+
 */
declare type UserID = string;
declare type UserWithID = User & {
    id: UserID;
};
/**
 * @format date-time
 * @x-go-type string
 */
declare type DateTime = string;
/**
 * @pattern [a-zA-Z0-9_\-~]*
 */
declare type APIKeyName = string;
/**
 * @pattern ^([a-zA-Z0-9][a-zA-Z0-9_\-~]+-)?[a-zA-Z0-9]{6}
 * @x-go-type auth.WorkspaceID
 */
declare type WorkspaceID = string;
/**
 * @x-go-type auth.Role
 */
declare type Role = 'owner' | 'maintainer';
declare type WorkspaceMeta = {
    name: string;
    slug: string;
};
declare type Workspace = WorkspaceMeta & {
    id: WorkspaceID;
    memberCount: number;
    plan: 'free';
};
declare type WorkspaceMember = {
    userId: UserID;
    fullname: string;
    email: string;
    role: Role;
};
/**
 * @pattern [a-zA-Z0-9]+
 */
declare type InviteID = string;
declare type WorkspaceInvite = {
    inviteId: InviteID;
    email: string;
    expires: string;
    role: Role;
};
declare type WorkspaceMembers = {
    members: WorkspaceMember[];
    invites: WorkspaceInvite[];
};
/**
 * @pattern ^ik_[a-zA-Z0-9]+
 */
declare type InviteKey = string;
declare type ListDatabasesResponse = {
    databases?: {
        name: string;
        displayName: string;
        createdAt: DateTime;
        numberOfBranches: number;
        ui?: {
            color?: string;
        };
    }[];
};
declare type ListBranchesResponse = {
    databaseName: string;
    displayName: string;
    branches: Branch[];
};
declare type ListGitBranchesResponse = {
    mapping: {
        gitBranch: string;
        xataBranch: string;
    }[];
};
declare type Branch = {
    name: string;
    createdAt: DateTime;
};
/**
 * @example {"repository":"github.com/my/repository","branch":"feature-login","stage":"testing","labels":["epic-100"]}
 * @x-go-type xata.BranchMetadata
 */
declare type BranchMetadata = {
    repository?: string;
    branch?: BranchName;
    stage?: string;
    labels?: string[];
};
declare type DBBranch = {
    databaseName: DBName;
    branchName: BranchName;
    createdAt: DateTime;
    id: string;
    version: number;
    lastMigrationID: string;
    metadata?: BranchMetadata;
    startedFrom?: StartedFromMetadata;
    schema: Schema;
};
declare type StartedFromMetadata = {
    branchName: BranchName;
    dbBranchID: string;
    migrationID: string;
};
/**
 * @x-go-type xata.Schema
 */
declare type Schema = {
    tables: Table[];
    tablesOrder?: string[];
};
declare type Table = {
    id?: string;
    name: TableName;
    columns: Column[];
    revLinks?: RevLink[];
};
/**
 * @x-go-type xata.Column
 */
declare type Column = {
    name: string;
    type: 'bool' | 'int' | 'float' | 'string' | 'text' | 'email' | 'multiple' | 'link' | 'object' | 'datetime';
    link?: {
        table: string;
    };
    columns?: Column[];
};
declare type RevLink = {
    linkID: string;
    table: string;
};
/**
 * @pattern [a-zA-Z0-9_\-~]+
 */
declare type BranchName = string;
/**
 * @pattern [a-zA-Z0-9_\-~]+
 */
declare type DBName = string;
/**
 * The DBBranchName matches the pattern `{db_name}:{branch_name}`.
 *
 * @pattern [a-zA-Z0-9_\-~]+:[a-zA-Z0-9_\-~]+
 */
declare type DBBranchName = string;
/**
 * @pattern [a-zA-Z0-9_\-~]+
 */
declare type TableName = string;
/**
 * @pattern [a-zA-Z0-9_\-~\.]+
 */
declare type ColumnName = string;
declare type MetricsDatapoint = {
    timestamp: string;
    value: number;
};
declare type MetricsLatency = {
    p50?: MetricsDatapoint[];
    p90?: MetricsDatapoint[];
};
declare type BranchMigration = {
    id?: string;
    parentID?: string;
    status: string;
    title?: string;
    lastGitRevision?: string;
    localChanges: boolean;
    createdAt?: DateTime;
    newTables?: {
        [key: string]: Table;
    };
    removedTables?: string[];
    tableMigrations?: {
        [key: string]: TableMigration;
    };
    newTableOrder: string[];
    renamedTables?: TableRename[];
};
declare type TableMigration = {
    newColumns?: {
        [key: string]: Column;
    };
    removedColumns?: string[];
    modifiedColumns?: ColumnMigration[];
    newColumnOrder: string[];
};
declare type ColumnMigration = {
    old: Column;
    ['new']: Column;
};
declare type SortExpression = string[] | {
    [key: string]: SortOrder;
} | {
    [key: string]: SortOrder;
}[];
declare type SortOrder = 'asc' | 'desc';
/**
 * Maximum [Levenshtein distance](https://en.wikipedia.org/wiki/Levenshtein_distance) for the search terms. The Levenshtein
 * distance is the number of one charcter changes needed to make two strings equal. The default is 1, meaning that single
 * character typos per word are tollerated by search. You can set it to 0 to remove the typo tollerance or set it to 2
 * to allow two typos in a word.
 *
 * @default 1
 * @maximum 2
 * @minimum 0
 */
declare type FuzzinessExpression = number;
/**
 * @minProperties 1
 */
declare type FilterExpression = {
    $exists?: string;
    $existsNot?: string;
    $any?: FilterList;
    $all?: FilterList;
    $none?: FilterList;
    $not?: FilterList;
} & {
    [key: string]: FilterColumn;
};
declare type HighlightExpression = {
    enabled?: boolean;
    encodeHTML?: boolean;
};
declare type FilterList = FilterExpression | FilterExpression[];
declare type FilterColumn = FilterColumnIncludes | FilterPredicate | FilterList;
/**
 * @maxProperties 1
 * @minProperties 1
 */
declare type FilterColumnIncludes = {
    $includes?: FilterPredicate;
    $includesAny?: FilterPredicate;
    $includesAll?: FilterPredicate;
    $includesNone?: FilterPredicate;
};
declare type FilterPredicate = FilterValue | FilterPredicate[] | FilterPredicateOp | FilterPredicateRangeOp;
/**
 * @maxProperties 1
 * @minProperties 1
 */
declare type FilterPredicateOp = {
    $any?: FilterPredicate[];
    $all?: FilterPredicate[];
    $none?: FilterPredicate | FilterPredicate[];
    $not?: FilterPredicate | FilterPredicate[];
    $is?: FilterValue | FilterValue[];
    $isNot?: FilterValue | FilterValue[];
    $lt?: FilterRangeValue;
    $le?: FilterRangeValue;
    $gt?: FilterRangeValue;
    $ge?: FilterRangeValue;
    $contains?: string;
    $startsWith?: string;
    $endsWith?: string;
    $pattern?: string;
};
/**
 * @maxProperties 2
 * @minProperties 2
 */
declare type FilterPredicateRangeOp = {
    $lt?: FilterRangeValue;
    $le?: FilterRangeValue;
    $gt?: FilterRangeValue;
    $ge?: FilterRangeValue;
};
declare type FilterRangeValue = number | string;
declare type FilterValue = number | string | boolean;
/**
 * Pagination settings.
 */
declare type PageConfig = {
    after?: string;
    before?: string;
    first?: string;
    last?: string;
    size?: number;
    offset?: number;
};
declare type ColumnsFilter = string[];
/**
 * @pattern [a-zA-Z0-9_-~:]+
 */
declare type RecordID = string;
/**
 * @example {"newName":"newName","oldName":"oldName"}
 */
declare type TableRename = {
    newName: string;
    oldName: string;
};
/**
 * Records metadata
 */
declare type RecordsMetadata = {
    page: {
        cursor: string;
        more: boolean;
    };
};
/**
 * Xata Table Record
 */
declare type XataRecord$1 = {
    id: RecordID;
    xata: {
        version: number;
        table?: string;
        highlight?: {
            [key: string]: string[] | {
                [key: string]: any;
            };
        };
        warnings?: string[];
    };
} & {
    [key: string]: any;
};

type schemas_User = User;
type schemas_UserID = UserID;
type schemas_UserWithID = UserWithID;
type schemas_DateTime = DateTime;
type schemas_APIKeyName = APIKeyName;
type schemas_WorkspaceID = WorkspaceID;
type schemas_Role = Role;
type schemas_WorkspaceMeta = WorkspaceMeta;
type schemas_Workspace = Workspace;
type schemas_WorkspaceMember = WorkspaceMember;
type schemas_InviteID = InviteID;
type schemas_WorkspaceInvite = WorkspaceInvite;
type schemas_WorkspaceMembers = WorkspaceMembers;
type schemas_InviteKey = InviteKey;
type schemas_ListDatabasesResponse = ListDatabasesResponse;
type schemas_ListBranchesResponse = ListBranchesResponse;
type schemas_ListGitBranchesResponse = ListGitBranchesResponse;
type schemas_Branch = Branch;
type schemas_BranchMetadata = BranchMetadata;
type schemas_DBBranch = DBBranch;
type schemas_StartedFromMetadata = StartedFromMetadata;
type schemas_Schema = Schema;
type schemas_Table = Table;
type schemas_Column = Column;
type schemas_RevLink = RevLink;
type schemas_BranchName = BranchName;
type schemas_DBName = DBName;
type schemas_DBBranchName = DBBranchName;
type schemas_TableName = TableName;
type schemas_ColumnName = ColumnName;
type schemas_MetricsDatapoint = MetricsDatapoint;
type schemas_MetricsLatency = MetricsLatency;
type schemas_BranchMigration = BranchMigration;
type schemas_TableMigration = TableMigration;
type schemas_ColumnMigration = ColumnMigration;
type schemas_SortExpression = SortExpression;
type schemas_SortOrder = SortOrder;
type schemas_FuzzinessExpression = FuzzinessExpression;
type schemas_FilterExpression = FilterExpression;
type schemas_HighlightExpression = HighlightExpression;
type schemas_FilterList = FilterList;
type schemas_FilterColumn = FilterColumn;
type schemas_FilterColumnIncludes = FilterColumnIncludes;
type schemas_FilterPredicate = FilterPredicate;
type schemas_FilterPredicateOp = FilterPredicateOp;
type schemas_FilterPredicateRangeOp = FilterPredicateRangeOp;
type schemas_FilterRangeValue = FilterRangeValue;
type schemas_FilterValue = FilterValue;
type schemas_PageConfig = PageConfig;
type schemas_ColumnsFilter = ColumnsFilter;
type schemas_RecordID = RecordID;
type schemas_TableRename = TableRename;
type schemas_RecordsMetadata = RecordsMetadata;
declare namespace schemas {
  export {
    schemas_User as User,
    schemas_UserID as UserID,
    schemas_UserWithID as UserWithID,
    schemas_DateTime as DateTime,
    schemas_APIKeyName as APIKeyName,
    schemas_WorkspaceID as WorkspaceID,
    schemas_Role as Role,
    schemas_WorkspaceMeta as WorkspaceMeta,
    schemas_Workspace as Workspace,
    schemas_WorkspaceMember as WorkspaceMember,
    schemas_InviteID as InviteID,
    schemas_WorkspaceInvite as WorkspaceInvite,
    schemas_WorkspaceMembers as WorkspaceMembers,
    schemas_InviteKey as InviteKey,
    schemas_ListDatabasesResponse as ListDatabasesResponse,
    schemas_ListBranchesResponse as ListBranchesResponse,
    schemas_ListGitBranchesResponse as ListGitBranchesResponse,
    schemas_Branch as Branch,
    schemas_BranchMetadata as BranchMetadata,
    schemas_DBBranch as DBBranch,
    schemas_StartedFromMetadata as StartedFromMetadata,
    schemas_Schema as Schema,
    schemas_Table as Table,
    schemas_Column as Column,
    schemas_RevLink as RevLink,
    schemas_BranchName as BranchName,
    schemas_DBName as DBName,
    schemas_DBBranchName as DBBranchName,
    schemas_TableName as TableName,
    schemas_ColumnName as ColumnName,
    schemas_MetricsDatapoint as MetricsDatapoint,
    schemas_MetricsLatency as MetricsLatency,
    schemas_BranchMigration as BranchMigration,
    schemas_TableMigration as TableMigration,
    schemas_ColumnMigration as ColumnMigration,
    schemas_SortExpression as SortExpression,
    schemas_SortOrder as SortOrder,
    schemas_FuzzinessExpression as FuzzinessExpression,
    schemas_FilterExpression as FilterExpression,
    schemas_HighlightExpression as HighlightExpression,
    schemas_FilterList as FilterList,
    schemas_FilterColumn as FilterColumn,
    schemas_FilterColumnIncludes as FilterColumnIncludes,
    schemas_FilterPredicate as FilterPredicate,
    schemas_FilterPredicateOp as FilterPredicateOp,
    schemas_FilterPredicateRangeOp as FilterPredicateRangeOp,
    schemas_FilterRangeValue as FilterRangeValue,
    schemas_FilterValue as FilterValue,
    schemas_PageConfig as PageConfig,
    schemas_ColumnsFilter as ColumnsFilter,
    schemas_RecordID as RecordID,
    schemas_TableRename as TableRename,
    schemas_RecordsMetadata as RecordsMetadata,
    XataRecord$1 as XataRecord,
  };
}

/**
 * Generated by @openapi-codegen
 *
 * @version 1.0
 */

declare type SimpleError = {
    id?: string;
    message: string;
};
declare type BadRequestError = {
    id?: string;
    message: string;
};
/**
 * @example {"message":"invalid API key"}
 */
declare type AuthError = {
    id?: string;
    message: string;
};
declare type BulkError = {
    errors: {
        message?: string;
        status?: number;
    }[];
};
declare type BranchMigrationPlan = {
    version: number;
    migration: BranchMigration;
};
declare type RecordUpdateResponse = {
    id: string;
    xata: {
        version: number;
    };
};
declare type QueryResponse = {
    records: XataRecord$1[];
    meta: RecordsMetadata;
};
declare type SearchResponse = {
    records: XataRecord$1[];
};
/**
 * @example {"migrationID":"mig_c7m19ilcefoebpqj12p0"}
 */
declare type MigrationIdResponse = {
    migrationID: string;
};

type responses_SimpleError = SimpleError;
type responses_BadRequestError = BadRequestError;
type responses_AuthError = AuthError;
type responses_BulkError = BulkError;
type responses_BranchMigrationPlan = BranchMigrationPlan;
type responses_RecordUpdateResponse = RecordUpdateResponse;
type responses_QueryResponse = QueryResponse;
type responses_SearchResponse = SearchResponse;
type responses_MigrationIdResponse = MigrationIdResponse;
declare namespace responses {
  export {
    responses_SimpleError as SimpleError,
    responses_BadRequestError as BadRequestError,
    responses_AuthError as AuthError,
    responses_BulkError as BulkError,
    responses_BranchMigrationPlan as BranchMigrationPlan,
    responses_RecordUpdateResponse as RecordUpdateResponse,
    responses_QueryResponse as QueryResponse,
    responses_SearchResponse as SearchResponse,
    responses_MigrationIdResponse as MigrationIdResponse,
  };
}

/**
 * Generated by @openapi-codegen
 *
 * @version 1.0
 */

declare type GetUserError = ErrorWrapper<{
    status: 400;
    payload: BadRequestError;
} | {
    status: 401;
    payload: AuthError;
} | {
    status: 404;
    payload: SimpleError;
}>;
declare type GetUserVariables = FetcherExtraProps;
/**
 * Return details of the user making the request
 */
declare const getUser: (variables: GetUserVariables) => Promise<UserWithID>;
declare type UpdateUserError = ErrorWrapper<{
    status: 400;
    payload: BadRequestError;
} | {
    status: 401;
    payload: AuthError;
} | {
    status: 404;
    payload: SimpleError;
}>;
declare type UpdateUserVariables = {
    body: User;
} & FetcherExtraProps;
/**
 * Update user info
 */
declare const updateUser: (variables: UpdateUserVariables) => Promise<UserWithID>;
declare type DeleteUserError = ErrorWrapper<{
    status: 400;
    payload: BadRequestError;
} | {
    status: 401;
    payload: AuthError;
} | {
    status: 404;
    payload: SimpleError;
}>;
declare type DeleteUserVariables = FetcherExtraProps;
/**
 * Delete the user making the request
 */
declare const deleteUser: (variables: DeleteUserVariables) => Promise<undefined>;
declare type GetUserAPIKeysError = ErrorWrapper<{
    status: 400;
    payload: BadRequestError;
} | {
    status: 401;
    payload: AuthError;
} | {
    status: 404;
    payload: SimpleError;
}>;
declare type GetUserAPIKeysResponse = {
    keys: {
        name: string;
        createdAt: DateTime;
    }[];
};
declare type GetUserAPIKeysVariables = FetcherExtraProps;
/**
 * Retrieve a list of existing user API keys
 */
declare const getUserAPIKeys: (variables: GetUserAPIKeysVariables) => Promise<GetUserAPIKeysResponse>;
declare type CreateUserAPIKeyPathParams = {
    keyName: APIKeyName;
};
declare type CreateUserAPIKeyError = ErrorWrapper<{
    status: 400;
    payload: BadRequestError;
} | {
    status: 401;
    payload: AuthError;
} | {
    status: 404;
    payload: SimpleError;
}>;
declare type CreateUserAPIKeyResponse = {
    name: string;
    key: string;
    createdAt: DateTime;
};
declare type CreateUserAPIKeyVariables = {
    pathParams: CreateUserAPIKeyPathParams;
} & FetcherExtraProps;
/**
 * Create and return new API key
 */
declare const createUserAPIKey: (variables: CreateUserAPIKeyVariables) => Promise<CreateUserAPIKeyResponse>;
declare type DeleteUserAPIKeyPathParams = {
    keyName: APIKeyName;
};
declare type DeleteUserAPIKeyError = ErrorWrapper<{
    status: 400;
    payload: BadRequestError;
} | {
    status: 401;
    payload: AuthError;
} | {
    status: 404;
    payload: SimpleError;
}>;
declare type DeleteUserAPIKeyVariables = {
    pathParams: DeleteUserAPIKeyPathParams;
} & FetcherExtraProps;
/**
 * Delete an existing API key
 */
declare const deleteUserAPIKey: (variables: DeleteUserAPIKeyVariables) => Promise<undefined>;
declare type CreateWorkspaceError = ErrorWrapper<{
    status: 400;
    payload: BadRequestError;
} | {
    status: 401;
    payload: AuthError;
} | {
    status: 404;
    payload: SimpleError;
}>;
declare type CreateWorkspaceVariables = {
    body: WorkspaceMeta;
} & FetcherExtraProps;
/**
 * Creates a new workspace with the user requesting it as its single owner.
 */
declare const createWorkspace: (variables: CreateWorkspaceVariables) => Promise<Workspace>;
declare type GetWorkspacesListError = ErrorWrapper<{
    status: 400;
    payload: BadRequestError;
} | {
    status: 401;
    payload: AuthError;
} | {
    status: 404;
    payload: SimpleError;
}>;
declare type GetWorkspacesListResponse = {
    workspaces: {
        id: WorkspaceID;
        name: string;
        slug: string;
        role: Role;
    }[];
};
declare type GetWorkspacesListVariables = FetcherExtraProps;
/**
 * Retrieve the list of workspaces the user belongs to
 */
declare const getWorkspacesList: (variables: GetWorkspacesListVariables) => Promise<GetWorkspacesListResponse>;
declare type GetWorkspacePathParams = {
    workspaceId: WorkspaceID;
};
declare type GetWorkspaceError = ErrorWrapper<{
    status: 400;
    payload: BadRequestError;
} | {
    status: 401;
    payload: AuthError;
} | {
    status: 404;
    payload: SimpleError;
}>;
declare type GetWorkspaceVariables = {
    pathParams: GetWorkspacePathParams;
} & FetcherExtraProps;
/**
 * Retrieve workspace info from a workspace ID
 */
declare const getWorkspace: (variables: GetWorkspaceVariables) => Promise<Workspace>;
declare type UpdateWorkspacePathParams = {
    workspaceId: WorkspaceID;
};
declare type UpdateWorkspaceError = ErrorWrapper<{
    status: 400;
    payload: BadRequestError;
} | {
    status: 401;
    payload: AuthError;
} | {
    status: 404;
    payload: SimpleError;
}>;
declare type UpdateWorkspaceVariables = {
    body: WorkspaceMeta;
    pathParams: UpdateWorkspacePathParams;
} & FetcherExtraProps;
/**
 * Update workspace info
 */
declare const updateWorkspace: (variables: UpdateWorkspaceVariables) => Promise<Workspace>;
declare type DeleteWorkspacePathParams = {
    workspaceId: WorkspaceID;
};
declare type DeleteWorkspaceError = ErrorWrapper<{
    status: 400;
    payload: BadRequestError;
} | {
    status: 401;
    payload: AuthError;
} | {
    status: 404;
    payload: SimpleError;
}>;
declare type DeleteWorkspaceVariables = {
    pathParams: DeleteWorkspacePathParams;
} & FetcherExtraProps;
/**
 * Delete the workspace with the provided ID
 */
declare const deleteWorkspace: (variables: DeleteWorkspaceVariables) => Promise<undefined>;
declare type GetWorkspaceMembersListPathParams = {
    workspaceId: WorkspaceID;
};
declare type GetWorkspaceMembersListError = ErrorWrapper<{
    status: 400;
    payload: BadRequestError;
} | {
    status: 401;
    payload: AuthError;
} | {
    status: 404;
    payload: SimpleError;
}>;
declare type GetWorkspaceMembersListVariables = {
    pathParams: GetWorkspaceMembersListPathParams;
} & FetcherExtraProps;
/**
 * Retrieve the list of members of the given workspace
 */
declare const getWorkspaceMembersList: (variables: GetWorkspaceMembersListVariables) => Promise<WorkspaceMembers>;
declare type UpdateWorkspaceMemberRolePathParams = {
    workspaceId: WorkspaceID;
    userId: UserID;
};
declare type UpdateWorkspaceMemberRoleError = ErrorWrapper<{
    status: 400;
    payload: BadRequestError;
} | {
    status: 401;
    payload: AuthError;
} | {
    status: 404;
    payload: SimpleError;
}>;
declare type UpdateWorkspaceMemberRoleRequestBody = {
    role: Role;
};
declare type UpdateWorkspaceMemberRoleVariables = {
    body: UpdateWorkspaceMemberRoleRequestBody;
    pathParams: UpdateWorkspaceMemberRolePathParams;
} & FetcherExtraProps;
/**
 * Update a workspace member role. Workspaces must always have at least one owner, so this operation will fail if trying to remove owner role from the last owner in the workspace.
 */
declare const updateWorkspaceMemberRole: (variables: UpdateWorkspaceMemberRoleVariables) => Promise<undefined>;
declare type RemoveWorkspaceMemberPathParams = {
    workspaceId: WorkspaceID;
    userId: UserID;
};
declare type RemoveWorkspaceMemberError = ErrorWrapper<{
    status: 400;
    payload: BadRequestError;
} | {
    status: 401;
    payload: AuthError;
} | {
    status: 404;
    payload: SimpleError;
}>;
declare type RemoveWorkspaceMemberVariables = {
    pathParams: RemoveWorkspaceMemberPathParams;
} & FetcherExtraProps;
/**
 * Remove the member from the workspace
 */
declare const removeWorkspaceMember: (variables: RemoveWorkspaceMemberVariables) => Promise<undefined>;
declare type InviteWorkspaceMemberPathParams = {
    workspaceId: WorkspaceID;
};
declare type InviteWorkspaceMemberError = ErrorWrapper<{
    status: 400;
    payload: BadRequestError;
} | {
    status: 401;
    payload: AuthError;
} | {
    status: 404;
    payload: SimpleError;
}>;
declare type InviteWorkspaceMemberRequestBody = {
    email: string;
    role: Role;
};
declare type InviteWorkspaceMemberVariables = {
    body: InviteWorkspaceMemberRequestBody;
    pathParams: InviteWorkspaceMemberPathParams;
} & FetcherExtraProps;
/**
 * Invite some user to join the workspace with the given role
 */
declare const inviteWorkspaceMember: (variables: InviteWorkspaceMemberVariables) => Promise<WorkspaceInvite>;
declare type CancelWorkspaceMemberInvitePathParams = {
    workspaceId: WorkspaceID;
    inviteId: InviteID;
};
declare type CancelWorkspaceMemberInviteError = ErrorWrapper<{
    status: 400;
    payload: BadRequestError;
} | {
    status: 401;
    payload: AuthError;
} | {
    status: 404;
    payload: SimpleError;
}>;
declare type CancelWorkspaceMemberInviteVariables = {
    pathParams: CancelWorkspaceMemberInvitePathParams;
} & FetcherExtraProps;
/**
 * This operation provides a way to cancel invites by deleting them. Already accepted invites cannot be deleted.
 */
declare const cancelWorkspaceMemberInvite: (variables: CancelWorkspaceMemberInviteVariables) => Promise<undefined>;
declare type ResendWorkspaceMemberInvitePathParams = {
    workspaceId: WorkspaceID;
    inviteId: InviteID;
};
declare type ResendWorkspaceMemberInviteError = ErrorWrapper<{
    status: 400;
    payload: BadRequestError;
} | {
    status: 401;
    payload: AuthError;
} | {
    status: 404;
    payload: SimpleError;
}>;
declare type ResendWorkspaceMemberInviteVariables = {
    pathParams: ResendWorkspaceMemberInvitePathParams;
} & FetcherExtraProps;
/**
 * This operation provides a way to resend an Invite notification. Invite notifications can only be sent for Invites not yet accepted.
 */
declare const resendWorkspaceMemberInvite: (variables: ResendWorkspaceMemberInviteVariables) => Promise<undefined>;
declare type AcceptWorkspaceMemberInvitePathParams = {
    workspaceId: WorkspaceID;
    inviteKey: InviteKey;
};
declare type AcceptWorkspaceMemberInviteError = ErrorWrapper<{
    status: 400;
    payload: BadRequestError;
} | {
    status: 401;
    payload: AuthError;
} | {
    status: 404;
    payload: SimpleError;
}>;
declare type AcceptWorkspaceMemberInviteVariables = {
    pathParams: AcceptWorkspaceMemberInvitePathParams;
} & FetcherExtraProps;
/**
 * Accept the invitation to join a workspace. If the operation succeeds the user will be a member of the workspace
 */
declare const acceptWorkspaceMemberInvite: (variables: AcceptWorkspaceMemberInviteVariables) => Promise<undefined>;
declare type GetDatabaseListPathParams = {
    workspace: string;
};
declare type GetDatabaseListError = ErrorWrapper<{
    status: 400;
    payload: BadRequestError;
} | {
    status: 401;
    payload: AuthError;
}>;
declare type GetDatabaseListVariables = {
    pathParams: GetDatabaseListPathParams;
} & FetcherExtraProps;
/**
 * List all databases available in your Workspace.
 */
declare const getDatabaseList: (variables: GetDatabaseListVariables) => Promise<ListDatabasesResponse>;
declare type GetBranchListPathParams = {
    dbName: DBName;
    workspace: string;
};
declare type GetBranchListError = ErrorWrapper<{
    status: 400;
    payload: BadRequestError;
} | {
    status: 401;
    payload: AuthError;
} | {
    status: 404;
    payload: SimpleError;
}>;
declare type GetBranchListVariables = {
    pathParams: GetBranchListPathParams;
} & FetcherExtraProps;
/**
 * List all available Branches
 */
declare const getBranchList: (variables: GetBranchListVariables) => Promise<ListBranchesResponse>;
declare type CreateDatabasePathParams = {
    dbName: DBName;
    workspace: string;
};
declare type CreateDatabaseError = ErrorWrapper<{
    status: 400;
    payload: BadRequestError;
} | {
    status: 401;
    payload: AuthError;
}>;
declare type CreateDatabaseResponse = {
    databaseName: string;
    branchName?: string;
};
declare type CreateDatabaseRequestBody = {
    displayName?: string;
    branchName?: string;
    ui?: {
        color?: string;
    };
    metadata?: BranchMetadata;
};
declare type CreateDatabaseVariables = {
    body?: CreateDatabaseRequestBody;
    pathParams: CreateDatabasePathParams;
} & FetcherExtraProps;
/**
 * Create Database with identifier name
 */
declare const createDatabase: (variables: CreateDatabaseVariables) => Promise<CreateDatabaseResponse>;
declare type DeleteDatabasePathParams = {
    dbName: DBName;
    workspace: string;
};
declare type DeleteDatabaseError = ErrorWrapper<{
    status: 400;
    payload: BadRequestError;
} | {
    status: 401;
    payload: AuthError;
} | {
    status: 404;
    payload: SimpleError;
}>;
declare type DeleteDatabaseVariables = {
    pathParams: DeleteDatabasePathParams;
} & FetcherExtraProps;
/**
 * Delete a database and all of its branches and tables permanently.
 */
declare const deleteDatabase: (variables: DeleteDatabaseVariables) => Promise<undefined>;
declare type GetGitBranchesMappingPathParams = {
    dbName: DBName;
    workspace: string;
};
declare type GetGitBranchesMappingError = ErrorWrapper<{
    status: 400;
    payload: BadRequestError;
} | {
    status: 401;
    payload: AuthError;
}>;
declare type GetGitBranchesMappingVariables = {
    pathParams: GetGitBranchesMappingPathParams;
} & FetcherExtraProps;
/**
 * Lists all the git branches in the mapping, and their associated Xata branches.
 *
 * Example response:
 *
 * ```json
 * {
 *   "mappings": [
 *       {
 *         "gitBranch": "main",
 *         "xataBranch": "main"
 *       },
 *       {
 *         "gitBranch": "gitBranch1",
 *         "xataBranch": "xataBranch1"
 *       }
 *       {
 *         "gitBranch": "xataBranch2",
 *         "xataBranch": "xataBranch2"
 *       }
 *   ]
 * }
 * ```
 */
declare const getGitBranchesMapping: (variables: GetGitBranchesMappingVariables) => Promise<ListGitBranchesResponse>;
declare type AddGitBranchesEntryPathParams = {
    dbName: DBName;
    workspace: string;
};
declare type AddGitBranchesEntryError = ErrorWrapper<{
    status: 400;
    payload: BadRequestError;
} | {
    status: 401;
    payload: AuthError;
}>;
declare type AddGitBranchesEntryResponse = {
    warning?: string;
};
declare type AddGitBranchesEntryRequestBody = {
    gitBranch: string;
    xataBranch: BranchName;
};
declare type AddGitBranchesEntryVariables = {
    body: AddGitBranchesEntryRequestBody;
    pathParams: AddGitBranchesEntryPathParams;
} & FetcherExtraProps;
/**
 * Adds an entry to the mapping of git branches to Xata branches. The git branch and the Xata branch must be present in the body of the request. If the Xata branch doesn't exist, a 400 error is returned.
 *
 * If the git branch is already present in the mapping, the old entry is overwritten, and a warning message is included in the response. If the git branch is added and didn't exist before, the response code is 204. If the git branch existed and it was overwritten, the response code is 201.
 *
 * Example request:
 *
 * ```json
 * // POST https://tutorial-ng7s8c.xata.sh/dbs/demo/gitBranches
 * {
 *   "gitBranch": "fix/bug123",
 *   "xataBranch": "fix_bug"
 * }
 * ```
 */
declare const addGitBranchesEntry: (variables: AddGitBranchesEntryVariables) => Promise<AddGitBranchesEntryResponse>;
declare type RemoveGitBranchesEntryPathParams = {
    dbName: DBName;
    workspace: string;
};
declare type RemoveGitBranchesEntryQueryParams = {
    gitBranch: string;
};
declare type RemoveGitBranchesEntryError = ErrorWrapper<{
    status: 400;
    payload: BadRequestError;
} | {
    status: 401;
    payload: AuthError;
}>;
declare type RemoveGitBranchesEntryVariables = {
    pathParams: RemoveGitBranchesEntryPathParams;
    queryParams: RemoveGitBranchesEntryQueryParams;
} & FetcherExtraProps;
/**
 * Removes an entry from the mapping of git branches to Xata branches. The name of the git branch must be passed as a query parameter. If the git branch is not found, the endpoint returns a 404 status code.
 *
 * Example request:
 *
 * ```json
 * // DELETE https://tutorial-ng7s8c.xata.sh/dbs/demo/gitBranches?gitBranch=fix%2Fbug123
 * ```
 */
declare const removeGitBranchesEntry: (variables: RemoveGitBranchesEntryVariables) => Promise<undefined>;
declare type ResolveBranchPathParams = {
    dbName: DBName;
    workspace: string;
};
declare type ResolveBranchQueryParams = {
    gitBranch?: string;
    fallbackBranch?: string;
};
declare type ResolveBranchError = ErrorWrapper<{
    status: 400;
    payload: BadRequestError;
} | {
    status: 401;
    payload: AuthError;
}>;
declare type ResolveBranchResponse = {
    branch: string;
    reason: {
        code: 'FOUND_IN_MAPPING' | 'BRANCH_EXISTS' | 'FALLBACK_BRANCH' | 'DEFAULT_BRANCH';
        message: string;
    };
};
declare type ResolveBranchVariables = {
    pathParams: ResolveBranchPathParams;
    queryParams?: ResolveBranchQueryParams;
} & FetcherExtraProps;
/**
 * In order to resolve the database branch, the following algorithm is used:
 * * if the `gitBranch` was provided and is found in the [git branches mapping](/api-reference/dbs/db_name/gitBranches), the associated Xata branch is returned
 * * else, if a Xata branch with the exact same name as `gitBranch` exists, return it
 * * else, if `fallbackBranch` is provided and a branch with that name exists, return it
 * * else, return the default branch of the DB (`main` or the first branch)
 *
 * Example call:
 *
 * ```json
 * // GET https://tutorial-ng7s8c.xata.sh/dbs/demo/dbs/demo/resolveBranch?gitBranch=test&fallbackBranch=tsg
 * ```
 *
 * Example response:
 *
 * ```json
 * {
 *   "branch": "main",
 *   "reason": {
 *     "code": "DEFAULT_BRANCH",
 *     "message": "Default branch for this database (main)"
 *   }
 * }
 * ```
 */
declare const resolveBranch: (variables: ResolveBranchVariables) => Promise<ResolveBranchResponse>;
declare type GetBranchDetailsPathParams = {
    dbBranchName: DBBranchName;
    workspace: string;
};
declare type GetBranchDetailsError = ErrorWrapper<{
    status: 400;
    payload: BadRequestError;
} | {
    status: 401;
    payload: AuthError;
} | {
    status: 404;
    payload: SimpleError;
}>;
declare type GetBranchDetailsVariables = {
    pathParams: GetBranchDetailsPathParams;
} & FetcherExtraProps;
declare const getBranchDetails: (variables: GetBranchDetailsVariables) => Promise<DBBranch>;
declare type CreateBranchPathParams = {
    dbBranchName: DBBranchName;
    workspace: string;
};
declare type CreateBranchQueryParams = {
    from?: string;
};
declare type CreateBranchError = ErrorWrapper<{
    status: 400;
    payload: BadRequestError;
} | {
    status: 401;
    payload: AuthError;
} | {
    status: 404;
    payload: SimpleError;
}>;
declare type CreateBranchRequestBody = {
    from?: string;
    metadata?: BranchMetadata;
};
declare type CreateBranchVariables = {
    body?: CreateBranchRequestBody;
    pathParams: CreateBranchPathParams;
    queryParams?: CreateBranchQueryParams;
} & FetcherExtraProps;
declare const createBranch: (variables: CreateBranchVariables) => Promise<undefined>;
declare type DeleteBranchPathParams = {
    dbBranchName: DBBranchName;
    workspace: string;
};
declare type DeleteBranchError = ErrorWrapper<{
    status: 400;
    payload: BadRequestError;
} | {
    status: 401;
    payload: AuthError;
} | {
    status: 404;
    payload: SimpleError;
}>;
declare type DeleteBranchVariables = {
    pathParams: DeleteBranchPathParams;
} & FetcherExtraProps;
/**
 * Delete the branch in the database and all its resources
 */
declare const deleteBranch: (variables: DeleteBranchVariables) => Promise<undefined>;
declare type UpdateBranchMetadataPathParams = {
    dbBranchName: DBBranchName;
    workspace: string;
};
declare type UpdateBranchMetadataError = ErrorWrapper<{
    status: 400;
    payload: BadRequestError;
} | {
    status: 401;
    payload: AuthError;
} | {
    status: 404;
    payload: SimpleError;
}>;
declare type UpdateBranchMetadataVariables = {
    body?: BranchMetadata;
    pathParams: UpdateBranchMetadataPathParams;
} & FetcherExtraProps;
/**
 * Update the branch metadata
 */
declare const updateBranchMetadata: (variables: UpdateBranchMetadataVariables) => Promise<undefined>;
declare type GetBranchMetadataPathParams = {
    dbBranchName: DBBranchName;
    workspace: string;
};
declare type GetBranchMetadataError = ErrorWrapper<{
    status: 400;
    payload: BadRequestError;
} | {
    status: 401;
    payload: AuthError;
} | {
    status: 404;
    payload: SimpleError;
}>;
declare type GetBranchMetadataVariables = {
    pathParams: GetBranchMetadataPathParams;
} & FetcherExtraProps;
declare const getBranchMetadata: (variables: GetBranchMetadataVariables) => Promise<BranchMetadata>;
declare type GetBranchMigrationHistoryPathParams = {
    dbBranchName: DBBranchName;
    workspace: string;
};
declare type GetBranchMigrationHistoryError = ErrorWrapper<{
    status: 400;
    payload: BadRequestError;
} | {
    status: 401;
    payload: AuthError;
} | {
    status: 404;
    payload: SimpleError;
}>;
declare type GetBranchMigrationHistoryResponse = {
    startedFrom?: StartedFromMetadata;
    migrations?: BranchMigration[];
};
declare type GetBranchMigrationHistoryRequestBody = {
    limit?: number;
    startFrom?: string;
};
declare type GetBranchMigrationHistoryVariables = {
    body?: GetBranchMigrationHistoryRequestBody;
    pathParams: GetBranchMigrationHistoryPathParams;
} & FetcherExtraProps;
declare const getBranchMigrationHistory: (variables: GetBranchMigrationHistoryVariables) => Promise<GetBranchMigrationHistoryResponse>;
declare type ExecuteBranchMigrationPlanPathParams = {
    dbBranchName: DBBranchName;
    workspace: string;
};
declare type ExecuteBranchMigrationPlanError = ErrorWrapper<{
    status: 400;
    payload: BadRequestError;
} | {
    status: 401;
    payload: AuthError;
} | {
    status: 404;
    payload: SimpleError;
}>;
declare type ExecuteBranchMigrationPlanRequestBody = {
    version: number;
    migration: BranchMigration;
};
declare type ExecuteBranchMigrationPlanVariables = {
    body: ExecuteBranchMigrationPlanRequestBody;
    pathParams: ExecuteBranchMigrationPlanPathParams;
} & FetcherExtraProps;
/**
 * Apply a migration plan to the branch
 */
declare const executeBranchMigrationPlan: (variables: ExecuteBranchMigrationPlanVariables) => Promise<undefined>;
declare type GetBranchMigrationPlanPathParams = {
    dbBranchName: DBBranchName;
    workspace: string;
};
declare type GetBranchMigrationPlanError = ErrorWrapper<{
    status: 400;
    payload: BadRequestError;
} | {
    status: 401;
    payload: AuthError;
} | {
    status: 404;
    payload: SimpleError;
}>;
declare type GetBranchMigrationPlanVariables = {
    body: Schema;
    pathParams: GetBranchMigrationPlanPathParams;
} & FetcherExtraProps;
/**
 * Compute a migration plan from a target schema the branch should be migrated too.
 */
declare const getBranchMigrationPlan: (variables: GetBranchMigrationPlanVariables) => Promise<BranchMigrationPlan>;
declare type GetBranchStatsPathParams = {
    dbBranchName: DBBranchName;
    workspace: string;
};
declare type GetBranchStatsError = ErrorWrapper<{
    status: 400;
    payload: SimpleError;
} | {
    status: 401;
    payload: AuthError;
} | {
    status: 404;
    payload: SimpleError;
}>;
declare type GetBranchStatsResponse = {
    timestamp: string;
    interval: string;
    resolution: string;
    numberOfRecords?: MetricsDatapoint[];
    writesOverTime?: MetricsDatapoint[];
    readsOverTime?: MetricsDatapoint[];
    readLatency?: MetricsLatency;
    writeLatency?: MetricsLatency;
    warning?: string;
};
declare type GetBranchStatsVariables = {
    pathParams: GetBranchStatsPathParams;
} & FetcherExtraProps;
/**
 * Get branch usage metrics.
 */
declare const getBranchStats: (variables: GetBranchStatsVariables) => Promise<GetBranchStatsResponse>;
declare type CreateTablePathParams = {
    dbBranchName: DBBranchName;
    tableName: TableName;
    workspace: string;
};
declare type CreateTableError = ErrorWrapper<{
    status: 400;
    payload: BadRequestError;
} | {
    status: 401;
    payload: AuthError;
} | {
    status: 404;
    payload: SimpleError;
} | {
    status: 422;
    payload: SimpleError;
}>;
declare type CreateTableVariables = {
    pathParams: CreateTablePathParams;
} & FetcherExtraProps;
/**
 * Creates a new table with the given name. Returns 422 if a table with the same name already exists.
 */
declare const createTable: (variables: CreateTableVariables) => Promise<undefined>;
declare type DeleteTablePathParams = {
    dbBranchName: DBBranchName;
    tableName: TableName;
    workspace: string;
};
declare type DeleteTableError = ErrorWrapper<{
    status: 400;
    payload: BadRequestError;
} | {
    status: 401;
    payload: AuthError;
}>;
declare type DeleteTableVariables = {
    pathParams: DeleteTablePathParams;
} & FetcherExtraProps;
/**
 * Deletes the table with the given name.
 */
declare const deleteTable: (variables: DeleteTableVariables) => Promise<undefined>;
declare type UpdateTablePathParams = {
    dbBranchName: DBBranchName;
    tableName: TableName;
    workspace: string;
};
declare type UpdateTableError = ErrorWrapper<{
    status: 400;
    payload: BadRequestError;
} | {
    status: 401;
    payload: AuthError;
} | {
    status: 404;
    payload: SimpleError;
}>;
declare type UpdateTableRequestBody = {
    name: string;
};
declare type UpdateTableVariables = {
    body: UpdateTableRequestBody;
    pathParams: UpdateTablePathParams;
} & FetcherExtraProps;
/**
 * Update table. Currently there is only one update operation supported: renaming the table by providing a new name.
 *
 * In the example below, we rename a table from “users” to “people”:
 *
 * ```json
 * // PATCH /db/test:main/tables/users
 *
 * {
 *   "name": "people"
 * }
 * ```
 */
declare const updateTable: (variables: UpdateTableVariables) => Promise<undefined>;
declare type GetTableSchemaPathParams = {
    dbBranchName: DBBranchName;
    tableName: TableName;
    workspace: string;
};
declare type GetTableSchemaError = ErrorWrapper<{
    status: 400;
    payload: BadRequestError;
} | {
    status: 401;
    payload: AuthError;
} | {
    status: 404;
    payload: SimpleError;
}>;
declare type GetTableSchemaResponse = {
    columns: Column[];
};
declare type GetTableSchemaVariables = {
    pathParams: GetTableSchemaPathParams;
} & FetcherExtraProps;
declare const getTableSchema: (variables: GetTableSchemaVariables) => Promise<GetTableSchemaResponse>;
declare type SetTableSchemaPathParams = {
    dbBranchName: DBBranchName;
    tableName: TableName;
    workspace: string;
};
declare type SetTableSchemaError = ErrorWrapper<{
    status: 400;
    payload: BadRequestError;
} | {
    status: 401;
    payload: AuthError;
} | {
    status: 404;
    payload: SimpleError;
} | {
    status: 409;
    payload: SimpleError;
}>;
declare type SetTableSchemaRequestBody = {
    columns: Column[];
};
declare type SetTableSchemaVariables = {
    body: SetTableSchemaRequestBody;
    pathParams: SetTableSchemaPathParams;
} & FetcherExtraProps;
declare const setTableSchema: (variables: SetTableSchemaVariables) => Promise<undefined>;
declare type GetTableColumnsPathParams = {
    dbBranchName: DBBranchName;
    tableName: TableName;
    workspace: string;
};
declare type GetTableColumnsError = ErrorWrapper<{
    status: 400;
    payload: BadRequestError;
} | {
    status: 401;
    payload: AuthError;
} | {
    status: 404;
    payload: SimpleError;
}>;
declare type GetTableColumnsResponse = {
    columns: Column[];
};
declare type GetTableColumnsVariables = {
    pathParams: GetTableColumnsPathParams;
} & FetcherExtraProps;
/**
 * Retrieves the list of table columns and their definition. This endpoint returns the column list with object columns being reported with their
 * full dot-separated path (flattened).
 */
declare const getTableColumns: (variables: GetTableColumnsVariables) => Promise<GetTableColumnsResponse>;
declare type AddTableColumnPathParams = {
    dbBranchName: DBBranchName;
    tableName: TableName;
    workspace: string;
};
declare type AddTableColumnError = ErrorWrapper<{
    status: 400;
    payload: BadRequestError;
} | {
    status: 401;
    payload: AuthError;
} | {
    status: 404;
    payload: SimpleError;
}>;
declare type AddTableColumnVariables = {
    body: Column;
    pathParams: AddTableColumnPathParams;
} & FetcherExtraProps;
/**
 * Adds a new column to the table. The body of the request should contain the column definition. In the column definition, the 'name' field should
 * contain the full path separated by dots. If the parent objects do not exists, they will be automatically created. For example,
 * passing `"name": "address.city"` will auto-create the `address` object if it doesn't exist.
 */
declare const addTableColumn: (variables: AddTableColumnVariables) => Promise<MigrationIdResponse>;
declare type GetColumnPathParams = {
    dbBranchName: DBBranchName;
    tableName: TableName;
    columnName: ColumnName;
    workspace: string;
};
declare type GetColumnError = ErrorWrapper<{
    status: 400;
    payload: BadRequestError;
} | {
    status: 401;
    payload: AuthError;
} | {
    status: 404;
    payload: SimpleError;
}>;
declare type GetColumnVariables = {
    pathParams: GetColumnPathParams;
} & FetcherExtraProps;
/**
 * Get the definition of a single column. To refer to sub-objects, the column name can contain dots. For example `address.country`.
 */
declare const getColumn: (variables: GetColumnVariables) => Promise<Column>;
declare type DeleteColumnPathParams = {
    dbBranchName: DBBranchName;
    tableName: TableName;
    columnName: ColumnName;
    workspace: string;
};
declare type DeleteColumnError = ErrorWrapper<{
    status: 400;
    payload: BadRequestError;
} | {
    status: 401;
    payload: AuthError;
} | {
    status: 404;
    payload: SimpleError;
}>;
declare type DeleteColumnVariables = {
    pathParams: DeleteColumnPathParams;
} & FetcherExtraProps;
/**
 * Deletes the specified column. To refer to sub-objects, the column name can contain dots. For example `address.country`.
 */
declare const deleteColumn: (variables: DeleteColumnVariables) => Promise<MigrationIdResponse>;
declare type UpdateColumnPathParams = {
    dbBranchName: DBBranchName;
    tableName: TableName;
    columnName: ColumnName;
    workspace: string;
};
declare type UpdateColumnError = ErrorWrapper<{
    status: 400;
    payload: BadRequestError;
} | {
    status: 401;
    payload: AuthError;
} | {
    status: 404;
    payload: SimpleError;
}>;
declare type UpdateColumnRequestBody = {
    name: string;
};
declare type UpdateColumnVariables = {
    body: UpdateColumnRequestBody;
    pathParams: UpdateColumnPathParams;
} & FetcherExtraProps;
/**
 * Update column with partial data. Can be used for renaming the column by providing a new "name" field. To refer to sub-objects, the column name can contain dots. For example `address.country`.
 */
declare const updateColumn: (variables: UpdateColumnVariables) => Promise<MigrationIdResponse>;
declare type InsertRecordPathParams = {
    dbBranchName: DBBranchName;
    tableName: TableName;
    workspace: string;
};
declare type InsertRecordError = ErrorWrapper<{
    status: 400;
    payload: BadRequestError;
} | {
    status: 401;
    payload: AuthError;
} | {
    status: 404;
    payload: SimpleError;
}>;
declare type InsertRecordResponse = {
    id: string;
    xata: {
        version: number;
    };
};
declare type InsertRecordVariables = {
    body?: Record<string, any>;
    pathParams: InsertRecordPathParams;
} & FetcherExtraProps;
/**
 * Insert a new Record into the Table
 */
declare const insertRecord: (variables: InsertRecordVariables) => Promise<InsertRecordResponse>;
declare type InsertRecordWithIDPathParams = {
    dbBranchName: DBBranchName;
    tableName: TableName;
    recordId: RecordID;
    workspace: string;
};
declare type InsertRecordWithIDQueryParams = {
    createOnly?: boolean;
    ifVersion?: number;
};
declare type InsertRecordWithIDError = ErrorWrapper<{
    status: 400;
    payload: BadRequestError;
} | {
    status: 401;
    payload: AuthError;
} | {
    status: 404;
    payload: SimpleError;
} | {
    status: 422;
    payload: SimpleError;
}>;
declare type InsertRecordWithIDVariables = {
    body?: Record<string, any>;
    pathParams: InsertRecordWithIDPathParams;
    queryParams?: InsertRecordWithIDQueryParams;
} & FetcherExtraProps;
/**
 * By default, IDs are auto-generated when data is insterted into Xata. Sending a request to this endpoint allows us to insert a record with a pre-existing ID, bypassing the default automatic ID generation.
 */
declare const insertRecordWithID: (variables: InsertRecordWithIDVariables) => Promise<RecordUpdateResponse>;
declare type UpdateRecordWithIDPathParams = {
    dbBranchName: DBBranchName;
    tableName: TableName;
    recordId: RecordID;
    workspace: string;
};
declare type UpdateRecordWithIDQueryParams = {
    ifVersion?: number;
};
declare type UpdateRecordWithIDError = ErrorWrapper<{
    status: 400;
    payload: BadRequestError;
} | {
    status: 401;
    payload: AuthError;
} | {
    status: 404;
    payload: SimpleError;
} | {
    status: 422;
    payload: SimpleError;
}>;
declare type UpdateRecordWithIDVariables = {
    body?: Record<string, any>;
    pathParams: UpdateRecordWithIDPathParams;
    queryParams?: UpdateRecordWithIDQueryParams;
} & FetcherExtraProps;
declare const updateRecordWithID: (variables: UpdateRecordWithIDVariables) => Promise<RecordUpdateResponse>;
declare type UpsertRecordWithIDPathParams = {
    dbBranchName: DBBranchName;
    tableName: TableName;
    recordId: RecordID;
    workspace: string;
};
declare type UpsertRecordWithIDQueryParams = {
    ifVersion?: number;
};
declare type UpsertRecordWithIDError = ErrorWrapper<{
    status: 400;
    payload: BadRequestError;
} | {
    status: 401;
    payload: AuthError;
} | {
    status: 404;
    payload: SimpleError;
} | {
    status: 422;
    payload: SimpleError;
}>;
declare type UpsertRecordWithIDVariables = {
    body?: Record<string, any>;
    pathParams: UpsertRecordWithIDPathParams;
    queryParams?: UpsertRecordWithIDQueryParams;
} & FetcherExtraProps;
declare const upsertRecordWithID: (variables: UpsertRecordWithIDVariables) => Promise<RecordUpdateResponse>;
declare type DeleteRecordPathParams = {
    dbBranchName: DBBranchName;
    tableName: TableName;
    recordId: RecordID;
    workspace: string;
};
declare type DeleteRecordError = ErrorWrapper<{
    status: 400;
    payload: BadRequestError;
} | {
    status: 401;
    payload: AuthError;
} | {
    status: 404;
    payload: SimpleError;
}>;
declare type DeleteRecordVariables = {
    pathParams: DeleteRecordPathParams;
} & FetcherExtraProps;
declare const deleteRecord: (variables: DeleteRecordVariables) => Promise<undefined>;
declare type GetRecordPathParams = {
    dbBranchName: DBBranchName;
    tableName: TableName;
    recordId: RecordID;
    workspace: string;
};
declare type GetRecordError = ErrorWrapper<{
    status: 400;
    payload: BadRequestError;
} | {
    status: 401;
    payload: AuthError;
} | {
    status: 404;
    payload: SimpleError;
}>;
declare type GetRecordRequestBody = {
    columns?: ColumnsFilter;
};
declare type GetRecordVariables = {
    body?: GetRecordRequestBody;
    pathParams: GetRecordPathParams;
} & FetcherExtraProps;
/**
 * Retrieve record by ID
 */
declare const getRecord: (variables: GetRecordVariables) => Promise<XataRecord$1>;
declare type BulkInsertTableRecordsPathParams = {
    dbBranchName: DBBranchName;
    tableName: TableName;
    workspace: string;
};
declare type BulkInsertTableRecordsError = ErrorWrapper<{
    status: 400;
    payload: BulkError;
} | {
    status: 401;
    payload: AuthError;
} | {
    status: 404;
    payload: SimpleError;
}>;
declare type BulkInsertTableRecordsResponse = {
    recordIDs: string[];
};
declare type BulkInsertTableRecordsRequestBody = {
    records: Record<string, any>[];
};
declare type BulkInsertTableRecordsVariables = {
    body: BulkInsertTableRecordsRequestBody;
    pathParams: BulkInsertTableRecordsPathParams;
} & FetcherExtraProps;
/**
 * Bulk insert records
 */
declare const bulkInsertTableRecords: (variables: BulkInsertTableRecordsVariables) => Promise<BulkInsertTableRecordsResponse>;
declare type QueryTablePathParams = {
    dbBranchName: DBBranchName;
    tableName: TableName;
    workspace: string;
};
declare type QueryTableError = ErrorWrapper<{
    status: 400;
    payload: BadRequestError;
} | {
    status: 401;
    payload: AuthError;
} | {
    status: 404;
    payload: SimpleError;
}>;
declare type QueryTableRequestBody = {
    filter?: FilterExpression;
    sort?: SortExpression;
    page?: PageConfig;
    columns?: ColumnsFilter;
};
declare type QueryTableVariables = {
    body?: QueryTableRequestBody;
    pathParams: QueryTablePathParams;
} & FetcherExtraProps;
/**
 * The Query Table API can be used to retrieve all records in a table.
 * The API support filtering, sorting, selecting a subset of columns, and pagination.
 *
 * The overall structure of the request looks like this:
 *
 * ```json
 * // POST /db/<dbname>:<branch>/tables/<table>/query
 * {
 *   "columns": [...],
 *   "filter": {
 *     "$all": [...],
 *     "$any": [...]
 *     ...
 *   },
 *   "sort": {
 *     "multiple": [...]
 *     ...
 *   },
 *   "page": {
 *     ...
 *   }
 * }
 * ```
 *
 * ### Column selection
 *
 * If the `columns` array is not specified, all columns are included. For link
 * fields, only the ID column of the linked records is included in the response.
 *
 * If the `columns` array is specified, only the selected columns are included.
 * The `*` wildcard can be used to select all columns of the given array
 *
 * For objects and link fields, if the column name of the object is specified, we
 * include all of its sub-keys. If only some sub-keys are specified (via dotted
 * notation, e.g. `"settings.plan"` ), then only those sub-keys from the object
 * are included.
 *
 * By the way of example, assuming two tables like this:
 *
 * ```json {"truncate": true}
 * {
 *   "formatVersion": "1.0",
 *   "tables": [
 *     {
 *       "name": "teams",
 *       "columns": [
 *         {
 *           "name": "name",
 *           "type": "string"
 *         },
 *         {
 *           "name": "owner",
 *           "type": "link",
 *           "link": {
 *             "table": "users"
 *           }
 *         },
 *         {
 *           "name": "foundedDate",
 *           "type": "datetime"
 *         },
 *       ]
 *     },
 *     {
 *       "name": "users",
 *       "columns": [
 *         {
 *           "name": "email",
 *           "type": "email"
 *         },
 *         {
 *           "name": "full_name",
 *           "type": "string"
 *         },
 *         {
 *           "name": "address",
 *           "type": "object",
 *           "columns": [
 *             {
 *               "name": "street",
 *               "type": "string"
 *             },
 *             {
 *               "name": "number",
 *               "type": "int"
 *             },
 *             {
 *               "name": "zipcode",
 *               "type": "int"
 *             }
 *           ]
 *         },
 *         {
 *           "name": "team",
 *           "type": "link",
 *           "link": {
 *             "table": "teams"
 *           }
 *         }
 *       ]
 *     }
 *   ]
 * }
 * ```
 *
 * A query like this:
 *
 * ```json
 * POST /db/<dbname>:<branch>/tables/<table>/query
 * {
 *   "columns": [
 *     "name",
 *     "address.*"
 *   ]
 * }
 * ```
 *
 * returns objects like:
 *
 * ```json
 * {
 *   "name": "Kilian",
 *   "address": {
 *     "street": "New street",
 *     "number": 41,
 *     "zipcode": 10407
 *   }
 * }
 * ```
 *
 * while a query like this:
 *
 * ```json
 * POST /db/<dbname>:<branch>/tables/<table>/query
 * {
 *   "columns": [
 *     "name",
 *     "address.street"
 *   ]
 * }
 * ```
 *
 * returns objects like:
 *
 * ```json
 * {
 *   "name": "Kilian",
 *   "address": {
 *     "street": "New street"
 *   }
 * }
 * ```
 *
 * If you want to return all columns from the main table and selected columns from the linked table, you can do it like this:
 *
 * ```json
 * {
 *   "columns": ["*", "team.name"]
 * }
 * ```
 *
 * The `"*"` in the above means all columns, including columns of objects. This returns data like:
 *
 * ```json
 * {
 *   "name": "Kilian",
 *   "email": "kilian@gmail.com",
 *   "address": {
 *     "street": "New street",
 *     "number": 41,
 *     "zipcode": 10407
 *   },
 *   "team": {
 *     "id": "XX",
 *     "xata": {
 *       "version": 0
 *     },
 *     "name": "first team"
 *   }
 * }
 * ```
 *
 * If you want all columns of the linked table, you can do:
 *
 * ```json
 * {
 *   "columns": ["*", "team.*"]
 * }
 * ```
 *
 * This returns, for example:
 *
 * ```json
 * {
 *   "name": "Kilian",
 *   "email": "kilian@gmail.com",
 *   "address": {
 *     "street": "New street",
 *     "number": 41,
 *     "zipcode": 10407
 *   },
 *   "team": {
 *     "id": "XX",
 *     "xata": {
 *       "version": 0
 *     },
 *     "name": "first team",
 *     "code": "A1",
 *     "foundedDate": "2020-03-04T10:43:54.32Z"
 *   }
 * }
 * ```
 *
 * ### Filtering
 *
 * There are two types of operators:
 *
 * - Operators that work on a single column: `$is`, `$contains`, `$pattern`,
 *   `$includes`, `$gt`, etc.
 * - Control operators that combine multiple conditions: `$any`, `$all`, `$not` ,
 *   `$none`, etc.
 *
 * All operators start with an `$` to differentiate them from column names
 * (which are not allowed to start with a dollar sign).
 *
 * #### Exact matching and control operators
 *
 * Filter by one column:
 *
 * ```json
 * {
 *   "filter": {
 *     "<column_name>": "value"
 *   }
 * }
 * ```
 *
 * This is equivalent to using the `$is` operator:
 *
 * ```json
 * {
 *   "filter": {
 *     "<column_name>": {
 *       "$is": "value"
 *     }
 *   }
 * }
 * ```
 *
 * For example:
 *
 * ```json
 * {
 *   "filter": {
 *     "name": "r2"
 *   }
 * }
 * ```
 *
 * Or:
 *
 * ```json
 * {
 *   "filter": {
 *     "name": {
 *       "$is": "r2"
 *     }
 *   }
 * }
 * ```
 *
 * For objects, both dots and nested versions work:
 *
 * ```json
 * {
 *   "filter": {
 *     "settings.plan": "free"
 *   }
 * }
 * ```
 *
 * ```json
 * {
 *   "filter": {
 *     "settings": {
 *       "plan": "free"
 *     }
 *   }
 * }
 * ```
 *
 * If you want to OR together multiple values, you can use the `$any` operator with an array of values:
 *
 * ```json
 * {
 *   "filter": {
 *     "settings.plan": { "$any": ["free", "paid"] }
 *   }
 * }
 * ```
 *
 * If you specify multiple columns in the same filter, they are logically AND'ed together:
 *
 * ```json
 * {
 *   "filter": {
 *     "settings.dark": true,
 *     "settings.plan": "free"
 *   }
 * }
 * ```
 *
 * The above matches if both conditions are met.
 *
 * To be more explicit about it, you can use `$all` or `$any`:
 *
 * ```json
 * {
 *   "filter": {
 *     "$any": {
 *       "settings.dark": true,
 *       "settings.plan": "free"
 *     }
 *   }
 * }
 * ```
 *
 * The `$all` and `$any` operators can also receive an array of objects, which allows for repeating column names:
 *
 * ```json
 * {
 *   "filter": {
 *     "$any": [
 *       {
 *         "name": "r1"
 *       },
 *       {
 *         "name": "r2"
 *       }
 *     ]
 *   }
 * }
 * ```
 *
 * You can check for a value being not-null with `$exists`:
 *
 * ```json
 * {
 *   "filter": {
 *     "$exists": "settings"
 *   }
 * }
 * ```
 *
 * This can be combined with `$all` or `$any` :
 *
 * ```json
 * {
 *   "filter": {
 *     "$all": [
 *       {
 *         "$exists": "settings"
 *       },
 *       {
 *         "$exists": "name"
 *       }
 *     ]
 *   }
 * }
 * ```
 *
 * Or you can use the inverse operator `$notExists`:
 *
 * ```json
 * {
 *   "filter": {
 *     "$notExists": "settings"
 *   }
 * }
 * ```
 *
 * #### Partial match
 *
 * `$contains` is the simplest operator for partial matching. We should generally
 * discourage overusing `$contains` because it typically can't make use of
 * indices.
 *
 * ```json
 * {
 *   "filter": {
 *     "<column_name>": {
 *       "$contains": "value"
 *     }
 *   }
 * }
 * ```
 *
 * Wildcards are supported via the `$pattern` operator:
 *
 * ```json
 * {
 *   "filter": {
 *     "<column_name>": {
 *       "$pattern": "v*alu?"
 *     }
 *   }
 * }
 * ```
 *
 * The `$pattern` operator accepts two wildcard characters:
 * * `*` matches zero or more characters
 * * `?` matches exactly one character
 *
 * If you want to match a string that contains a wildcard character, you can escape them using a backslash (`\`). You can escape a backslash by usign another backslash.
 *
 * We could also have `$endsWith` and `$startsWith` operators:
 *
 * ```json
 * {
 *   "filter": {
 *     "<column_name>": {
 *       "$endsWith": ".gz"
 *     },
 *     "<column_name>": {
 *       "$startsWith": "tmp-"
 *     }
 *   }
 * }
 * ```
 *
 * #### Numeric or datetime ranges
 *
 * ```json
 * {
 *   "filter": {
 *     "<column_name>": {
 *       "$ge": 0,
 *       "$lt": 100
 *     }
 *   }
 * }
 * ```
 * Date ranges support the same operators, with the date using the format defined in
 * [RFC 3339](https://www.rfc-editor.org/rfc/rfc3339):
 * ```json
 * {
 *   "filter": {
 *     "<column_name>": {
 *       "$gt": "2019-10-12T07:20:50.52Z",
 *       "$lt": "2021-10-12T07:20:50.52Z"
 *     }
 *   }
 * }
 * ```
 * The supported operators are `$gt`, `$lt`, `$ge`, `$le`.
 *
 * #### Negations
 *
 * A general `$not` operator can inverse any operation.
 *
 * ```json
 * {
 *   "filter": {
 *     "$not": {
 *       "<column_name1>": "value1",
 *       "<column_name2>": "value1"
 *     }
 *   }
 * }
 * ```
 *
 * Note: in the above the two condition are AND together, so this does (NOT ( ...
 * AND ...))
 *
 * Or more complex:
 *
 * ```json
 * {
 *   "filter": {
 *     "$not": {
 *       "$any": [
 *         {
 *           "<column_name1>": "value1"
 *         },
 *         {
 *           "$all": [
 *             {
 *               "<column_name2>": "value2"
 *             },
 *             {
 *               "<column_name3>": "value3"
 *             }
 *           ]
 *         }
 *       ]
 *     }
 *   }
 * }
 * ```
 *
 * The `$not: { $any: {}}` can be shorted using the `$none` operator:
 *
 * ```json
 * {
 *   "filter": {
 *     "$none": {
 *       "<column_name1>": "value1",
 *       "<column_name2>": "value1"
 *     }
 *   }
 * }
 * ```
 *
 * In addition, you can use operators like `$isNot` or `$notExists` to simplify expressions:
 *
 * ```json
 * {
 *   "filter": {
 *     "<column_name>": {
 *       "$isNot": "2019-10-12T07:20:50.52Z"
 *     }
 *   }
 * }
 * ```
 *
 * #### Working with arrays
 *
 * To test that an array contains a value, use `$includes`.
 *
 * ```json
 * {
 *   "filter": {
 *     "<array_name>": {
 *       "$includes": "value"
 *     }
 *   }
 * }
 * ```
 *
 * The `$includes` operator accepts a custom predicate that will check if any
 * array values matches the predicate. For example a complex predicate can include
 * the `$all` , `$contains` and `$endsWith` operators:
 *
 * ```json
 * {
 *   "filter": {
 *     "<array name>": {
 *       "$includes": {
 *         "$all": [
 *           { "$contains": "label" },
 *           { "$not": { "$endsWith": "-debug" } }
 *         ]
 *       }
 *     }
 *   }
 * }
 * ```
 *
 * The `$includes` all operator succeeds if any column in the array matches the
 * predicate. The `$includesAll` operator succeeds if all array items match the
 * predicate. The `$includesNone` operator succeeds if no array item matches the
 * predicate. The `$includes` operator is a synonym for the `$includesAny`
 * operator.
 *
 * Here is an example of using the `$includesAll` operator:
 *
 * ```json
 * {
 *   "filter": {
 *     "settings.labels": {
 *       "$includesAll": [{ "$contains": "label" }]
 *     }
 *   }
 * }
 * ```
 *
 * The above matches if all label values contain the string "labels".
 *
 * ### Sorting
 *
 * Sorting by one element:
 *
 * ```json
 * POST /db/demo:main/tables/table/query
 * {
 *   "sort": {
 *     "index": "asc"
 *   }
 * }
 * ```
 *
 * or descendently:
 *
 * ```json
 * POST /db/demo:main/tables/table/query
 * {
 *   "sort": {
 *     "index": "desc"
 *   }
 * }
 * ```
 *
 * Sorting by multiple fields:
 *
 * ```json
 * POST /db/demo:main/tables/table/query
 * {
 *   "sort": [
 *     {
 *       "index": "desc"
 *     },
 *     {
 *       "createdAt": "desc"
 *     }
 *   ]
 * }
 * ```
 *
 * ### Pagination
 *
 * We offer cursor pagination and offset pagination. The offset pagination is limited
 * in the amount of data it can retrieve, so we recommend the cursor pagination if you have more than 1000 records.
 *
 * Example of size + offset pagination:
 *
 * ```json
 * POST /db/demo:main/tables/table/query
 * {
 *   "page": {
 *     "size": 100,
 *     "offset": 200
 *   }
 * }
 * ```
 *
 * The `page.size` parameter represents the maximum number of records returned by this query. It has a default value of 20 and a maximum value of 200.
 * The `page.offset` parameter represents the number of matching records to skip. It has a default value of 0 and a maximum value of 800.
 *
 * Example of cursor pagination:
 *
 * ```json
 * POST /db/demo:main/tables/table/query
 * {
 *   "page": {
 *     "after":"fMoxCsIwFIDh3WP8c4amDai5hO5SJCRNfaVSeC9b6d1FD"
 *   }
 * }
 * ```
 *
 * In the above example, the value of the `page.after` parameter is the cursor returned by the previous query. A sample response is shown below:
 *
 * ```json
 * {
 *   "meta": {
 *     "page": {
 *       "cursor": "fMoxCsIwFIDh3WP8c4amDai5hO5SJCRNfaVSeC9b6d1FD",
 *       "more": true
 *     }
 *   },
 *   "records": [...]
 * }
 * ```
 *
 * The `page` object might contain the follow keys, in addition to `size` and `offset` that were introduced before:
 *
 * - `after`: Return the next page 'after' the current cursor
 * - `before`: Return the previous page 'before' the current cursor.
 * - `first`: Return the first page in the table from a cursor.
 * - `last`: Return the last N records in the table from a cursor, where N is the `page.size` parameter.
 *
 * The request will fail if an invalid cursor value is given to `page.before`,
 * `page.after`, `page.first` , or `page.last`. No other cursor setting can be
 * used if `page.first` or `page.last` is set in a query.
 *
 * If both `page.before` and `page.after` parameters are present we treat the
 * request as a range query. The range query will return all entries after
 * `page.after`, but before `page.before`, up to `page.size` or the maximum
 * page size. This query requires both cursors to use the same filters and sort
 * settings, plus we require `page.after < page.before`. The range query returns
 * a new cursor. If the range encompass multiple pages the next page in the range
 * can be queried by update `page.after` to the returned cursor while keeping the
 * `page.before` cursor from the first range query.
 *
 * The `filter` , `columns`, `sort` , and `page.size` configuration will be
 * encoded with the cursor. The pagination request will be invalid if
 * `filter` or `sort` is set. The columns returned and page size can be changed
 * anytime by passing the `columns` or `page.size` settings to the next query.
 *
 * **Special cursors:**
 *
 * - `page.after=end`: Result points past the last entry. The list of records
 *   returned is empty, but `page.meta.cursor` will include a cursor that can be
 *   used to "tail" the table from the end waiting for new data to be inserted.
 * - `page.before=end`: This cursor returns the last page.
 * - `page.first=<cursor>`: Go to first page. This is equivalent to querying the
 *   first page without a cursor but `filter` and `sort` . Yet the `page.first`
 *   cursor can be convenient at times as user code does not need to remember the
 *   filter, sort, columns or page size configuration. All these information are
 *   read from the cursor.
 * - `page.last=<cursor>`: Go to the end of the table. This is equivalent to querying the
 *   last page with `page.before=end`, `filter`, and `sort` . Yet the
 *   `page.last` cursor can be more convenient at times as user code does not
 *   need to remember the filter, sort, columns or page size configuration. All
 *   these information are read from the cursor.
 *
 * When using special cursors like `page.after="end"` or `page.before="end"`, we
 * still allow `filter` and `sort` to be set.
 *
 * Example of getting the last page:
 *
 * ```json
 * POST /db/demo:main/tables/table/query
 * {
 *   "page": {
 *     "size": 10,
 *     "before": "end"
 *   }
 * }
 * ```
 */
declare const queryTable: (variables: QueryTableVariables) => Promise<QueryResponse>;
declare type SearchTablePathParams = {
    dbBranchName: DBBranchName;
    tableName: TableName;
    workspace: string;
};
declare type SearchTableError = ErrorWrapper<{
    status: 400;
    payload: BadRequestError;
} | {
    status: 401;
    payload: AuthError;
} | {
    status: 404;
    payload: SimpleError;
}>;
declare type SearchTableRequestBody = {
    query: string;
    fuzziness?: FuzzinessExpression;
    filter?: FilterExpression;
    highlight?: HighlightExpression;
};
declare type SearchTableVariables = {
    body: SearchTableRequestBody;
    pathParams: SearchTablePathParams;
} & FetcherExtraProps;
/**
 * Run a free text search operation in a particular table.
 *
 * The endpoint accepts a `query` parameter that is used for the free text search and a set of structured filters (via the `filter` parameter) that are applied before the search. The `filter` parameter uses the same syntax as the [query endpoint](/api-reference/db/db_branch_name/tables/table_name/) with the following exceptions:
 * * filters `$contains`, `$startsWith`, `$endsWith` don't work on columns of type `text`
 * * filtering on columns of type `multiple` is currently unsupported
 */
declare const searchTable: (variables: SearchTableVariables) => Promise<SearchResponse>;
declare type SearchBranchPathParams = {
    dbBranchName: DBBranchName;
    workspace: string;
};
declare type SearchBranchError = ErrorWrapper<{
    status: 400;
    payload: BadRequestError;
} | {
    status: 401;
    payload: AuthError;
} | {
    status: 404;
    payload: SimpleError;
}>;
declare type SearchBranchRequestBody = {
    tables?: (string | {
        table: string;
        filter?: FilterExpression;
    })[];
    query: string;
    fuzziness?: FuzzinessExpression;
    highlight?: HighlightExpression;
};
declare type SearchBranchVariables = {
    body: SearchBranchRequestBody;
    pathParams: SearchBranchPathParams;
} & FetcherExtraProps;
/**
 * Run a free text search operation across the database branch.
 */
declare const searchBranch: (variables: SearchBranchVariables) => Promise<SearchResponse>;
declare const operationsByTag: {
    users: {
        getUser: (variables: GetUserVariables) => Promise<UserWithID>;
        updateUser: (variables: UpdateUserVariables) => Promise<UserWithID>;
        deleteUser: (variables: DeleteUserVariables) => Promise<undefined>;
        getUserAPIKeys: (variables: GetUserAPIKeysVariables) => Promise<GetUserAPIKeysResponse>;
        createUserAPIKey: (variables: CreateUserAPIKeyVariables) => Promise<CreateUserAPIKeyResponse>;
        deleteUserAPIKey: (variables: DeleteUserAPIKeyVariables) => Promise<undefined>;
    };
    workspaces: {
        createWorkspace: (variables: CreateWorkspaceVariables) => Promise<Workspace>;
        getWorkspacesList: (variables: GetWorkspacesListVariables) => Promise<GetWorkspacesListResponse>;
        getWorkspace: (variables: GetWorkspaceVariables) => Promise<Workspace>;
        updateWorkspace: (variables: UpdateWorkspaceVariables) => Promise<Workspace>;
        deleteWorkspace: (variables: DeleteWorkspaceVariables) => Promise<undefined>;
        getWorkspaceMembersList: (variables: GetWorkspaceMembersListVariables) => Promise<WorkspaceMembers>;
        updateWorkspaceMemberRole: (variables: UpdateWorkspaceMemberRoleVariables) => Promise<undefined>;
        removeWorkspaceMember: (variables: RemoveWorkspaceMemberVariables) => Promise<undefined>;
        inviteWorkspaceMember: (variables: InviteWorkspaceMemberVariables) => Promise<WorkspaceInvite>;
        cancelWorkspaceMemberInvite: (variables: CancelWorkspaceMemberInviteVariables) => Promise<undefined>;
        resendWorkspaceMemberInvite: (variables: ResendWorkspaceMemberInviteVariables) => Promise<undefined>;
        acceptWorkspaceMemberInvite: (variables: AcceptWorkspaceMemberInviteVariables) => Promise<undefined>;
    };
    database: {
        getDatabaseList: (variables: GetDatabaseListVariables) => Promise<ListDatabasesResponse>;
        createDatabase: (variables: CreateDatabaseVariables) => Promise<CreateDatabaseResponse>;
        deleteDatabase: (variables: DeleteDatabaseVariables) => Promise<undefined>;
        getGitBranchesMapping: (variables: GetGitBranchesMappingVariables) => Promise<ListGitBranchesResponse>;
        addGitBranchesEntry: (variables: AddGitBranchesEntryVariables) => Promise<AddGitBranchesEntryResponse>;
        removeGitBranchesEntry: (variables: RemoveGitBranchesEntryVariables) => Promise<undefined>;
        resolveBranch: (variables: ResolveBranchVariables) => Promise<ResolveBranchResponse>;
    };
    branch: {
        getBranchList: (variables: GetBranchListVariables) => Promise<ListBranchesResponse>;
        getBranchDetails: (variables: GetBranchDetailsVariables) => Promise<DBBranch>;
        createBranch: (variables: CreateBranchVariables) => Promise<undefined>;
        deleteBranch: (variables: DeleteBranchVariables) => Promise<undefined>;
        updateBranchMetadata: (variables: UpdateBranchMetadataVariables) => Promise<undefined>;
        getBranchMetadata: (variables: GetBranchMetadataVariables) => Promise<BranchMetadata>;
        getBranchMigrationHistory: (variables: GetBranchMigrationHistoryVariables) => Promise<GetBranchMigrationHistoryResponse>;
        executeBranchMigrationPlan: (variables: ExecuteBranchMigrationPlanVariables) => Promise<undefined>;
        getBranchMigrationPlan: (variables: GetBranchMigrationPlanVariables) => Promise<BranchMigrationPlan>;
        getBranchStats: (variables: GetBranchStatsVariables) => Promise<GetBranchStatsResponse>;
    };
    table: {
        createTable: (variables: CreateTableVariables) => Promise<undefined>;
        deleteTable: (variables: DeleteTableVariables) => Promise<undefined>;
        updateTable: (variables: UpdateTableVariables) => Promise<undefined>;
        getTableSchema: (variables: GetTableSchemaVariables) => Promise<GetTableSchemaResponse>;
        setTableSchema: (variables: SetTableSchemaVariables) => Promise<undefined>;
        getTableColumns: (variables: GetTableColumnsVariables) => Promise<GetTableColumnsResponse>;
        addTableColumn: (variables: AddTableColumnVariables) => Promise<MigrationIdResponse>;
        getColumn: (variables: GetColumnVariables) => Promise<Column>;
        deleteColumn: (variables: DeleteColumnVariables) => Promise<MigrationIdResponse>;
        updateColumn: (variables: UpdateColumnVariables) => Promise<MigrationIdResponse>;
    };
    records: {
        insertRecord: (variables: InsertRecordVariables) => Promise<InsertRecordResponse>;
        insertRecordWithID: (variables: InsertRecordWithIDVariables) => Promise<RecordUpdateResponse>;
        updateRecordWithID: (variables: UpdateRecordWithIDVariables) => Promise<RecordUpdateResponse>;
        upsertRecordWithID: (variables: UpsertRecordWithIDVariables) => Promise<RecordUpdateResponse>;
        deleteRecord: (variables: DeleteRecordVariables) => Promise<undefined>;
        getRecord: (variables: GetRecordVariables) => Promise<XataRecord$1>;
        bulkInsertTableRecords: (variables: BulkInsertTableRecordsVariables) => Promise<BulkInsertTableRecordsResponse>;
        queryTable: (variables: QueryTableVariables) => Promise<QueryResponse>;
        searchTable: (variables: SearchTableVariables) => Promise<SearchResponse>;
        searchBranch: (variables: SearchBranchVariables) => Promise<SearchResponse>;
    };
};

declare type HostAliases = 'production' | 'staging';
declare type ProviderBuilder = {
    main: string;
    workspaces: string;
};
declare type HostProvider = HostAliases | ProviderBuilder;

interface XataApiClientOptions {
    fetch?: FetchImpl;
    apiKey?: string;
    host?: HostProvider;
}
/**
 * @deprecated Use XataApiPlugin instead
 */
declare class XataApiClient {
    #private;
    constructor(options?: XataApiClientOptions);
    get user(): UserApi;
    get workspaces(): WorkspaceApi;
    get databases(): DatabaseApi;
    get branches(): BranchApi;
    get tables(): TableApi;
    get records(): RecordsApi;
}
declare class UserApi {
    private extraProps;
    constructor(extraProps: FetcherExtraProps);
    getUser(): Promise<UserWithID>;
    updateUser(user: User): Promise<UserWithID>;
    deleteUser(): Promise<void>;
    getUserAPIKeys(): Promise<GetUserAPIKeysResponse>;
    createUserAPIKey(keyName: APIKeyName): Promise<CreateUserAPIKeyResponse>;
    deleteUserAPIKey(keyName: APIKeyName): Promise<void>;
}
declare class WorkspaceApi {
    private extraProps;
    constructor(extraProps: FetcherExtraProps);
    createWorkspace(workspaceMeta: WorkspaceMeta): Promise<Workspace>;
    getWorkspacesList(): Promise<GetWorkspacesListResponse>;
    getWorkspace(workspaceId: WorkspaceID): Promise<Workspace>;
    updateWorkspace(workspaceId: WorkspaceID, workspaceMeta: WorkspaceMeta): Promise<Workspace>;
    deleteWorkspace(workspaceId: WorkspaceID): Promise<void>;
    getWorkspaceMembersList(workspaceId: WorkspaceID): Promise<WorkspaceMembers>;
    updateWorkspaceMemberRole(workspaceId: WorkspaceID, userId: UserID, role: Role): Promise<void>;
    removeWorkspaceMember(workspaceId: WorkspaceID, userId: UserID): Promise<void>;
    inviteWorkspaceMember(workspaceId: WorkspaceID, email: string, role: Role): Promise<WorkspaceInvite>;
    cancelWorkspaceMemberInvite(workspaceId: WorkspaceID, inviteId: InviteID): Promise<void>;
    resendWorkspaceMemberInvite(workspaceId: WorkspaceID, inviteId: InviteID): Promise<void>;
    acceptWorkspaceMemberInvite(workspaceId: WorkspaceID, inviteKey: InviteKey): Promise<void>;
}
declare class DatabaseApi {
    private extraProps;
    constructor(extraProps: FetcherExtraProps);
    getDatabaseList(workspace: WorkspaceID): Promise<ListDatabasesResponse>;
    createDatabase(workspace: WorkspaceID, dbName: DBName, options?: CreateDatabaseRequestBody): Promise<CreateDatabaseResponse>;
    deleteDatabase(workspace: WorkspaceID, dbName: DBName): Promise<void>;
    getGitBranchesMapping(workspace: WorkspaceID, dbName: DBName): Promise<ListGitBranchesResponse>;
    addGitBranchesEntry(workspace: WorkspaceID, dbName: DBName, body: AddGitBranchesEntryRequestBody): Promise<AddGitBranchesEntryResponse>;
    removeGitBranchesEntry(workspace: WorkspaceID, dbName: DBName, gitBranch: string): Promise<void>;
    resolveBranch(workspace: WorkspaceID, dbName: DBName, gitBranch?: string, fallbackBranch?: string): Promise<ResolveBranchResponse>;
}
declare class BranchApi {
    private extraProps;
    constructor(extraProps: FetcherExtraProps);
    getBranchList(workspace: WorkspaceID, dbName: DBName): Promise<ListBranchesResponse>;
    getBranchDetails(workspace: WorkspaceID, database: DBName, branch: BranchName): Promise<DBBranch>;
    createBranch(workspace: WorkspaceID, database: DBName, branch: BranchName, from?: string, options?: CreateBranchRequestBody): Promise<void>;
    deleteBranch(workspace: WorkspaceID, database: DBName, branch: BranchName): Promise<void>;
    updateBranchMetadata(workspace: WorkspaceID, database: DBName, branch: BranchName, metadata?: BranchMetadata): Promise<void>;
    getBranchMetadata(workspace: WorkspaceID, database: DBName, branch: BranchName): Promise<BranchMetadata>;
    getBranchMigrationHistory(workspace: WorkspaceID, database: DBName, branch: BranchName, options?: GetBranchMigrationHistoryRequestBody): Promise<GetBranchMigrationHistoryResponse>;
    executeBranchMigrationPlan(workspace: WorkspaceID, database: DBName, branch: BranchName, migrationPlan: ExecuteBranchMigrationPlanRequestBody): Promise<void>;
    getBranchMigrationPlan(workspace: WorkspaceID, database: DBName, branch: BranchName, schema: Schema): Promise<BranchMigrationPlan>;
    getBranchStats(workspace: WorkspaceID, database: DBName, branch: BranchName): Promise<GetBranchStatsResponse>;
}
declare class TableApi {
    private extraProps;
    constructor(extraProps: FetcherExtraProps);
    createTable(workspace: WorkspaceID, database: DBName, branch: BranchName, tableName: TableName): Promise<void>;
    deleteTable(workspace: WorkspaceID, database: DBName, branch: BranchName, tableName: TableName): Promise<void>;
    updateTable(workspace: WorkspaceID, database: DBName, branch: BranchName, tableName: TableName, options: UpdateTableRequestBody): Promise<void>;
    getTableSchema(workspace: WorkspaceID, database: DBName, branch: BranchName, tableName: TableName): Promise<GetTableSchemaResponse>;
    setTableSchema(workspace: WorkspaceID, database: DBName, branch: BranchName, tableName: TableName, options: SetTableSchemaRequestBody): Promise<void>;
    getTableColumns(workspace: WorkspaceID, database: DBName, branch: BranchName, tableName: TableName): Promise<GetTableColumnsResponse>;
    addTableColumn(workspace: WorkspaceID, database: DBName, branch: BranchName, tableName: TableName, column: Column): Promise<MigrationIdResponse>;
    getColumn(workspace: WorkspaceID, database: DBName, branch: BranchName, tableName: TableName, columnName: ColumnName): Promise<Column>;
    deleteColumn(workspace: WorkspaceID, database: DBName, branch: BranchName, tableName: TableName, columnName: ColumnName): Promise<MigrationIdResponse>;
    updateColumn(workspace: WorkspaceID, database: DBName, branch: BranchName, tableName: TableName, columnName: ColumnName, options: UpdateColumnRequestBody): Promise<MigrationIdResponse>;
}
declare class RecordsApi {
    private extraProps;
    constructor(extraProps: FetcherExtraProps);
    insertRecord(workspace: WorkspaceID, database: DBName, branch: BranchName, tableName: TableName, record: Record<string, any>): Promise<InsertRecordResponse>;
    insertRecordWithID(workspace: WorkspaceID, database: DBName, branch: BranchName, tableName: TableName, recordId: RecordID, record: Record<string, any>, options?: InsertRecordWithIDQueryParams): Promise<RecordUpdateResponse>;
    updateRecordWithID(workspace: WorkspaceID, database: DBName, branch: BranchName, tableName: TableName, recordId: RecordID, record: Record<string, any>, options?: UpdateRecordWithIDQueryParams): Promise<RecordUpdateResponse>;
    upsertRecordWithID(workspace: WorkspaceID, database: DBName, branch: BranchName, tableName: TableName, recordId: RecordID, record: Record<string, any>, options?: UpsertRecordWithIDQueryParams): Promise<RecordUpdateResponse>;
    deleteRecord(workspace: WorkspaceID, database: DBName, branch: BranchName, tableName: TableName, recordId: RecordID): Promise<void>;
    getRecord(workspace: WorkspaceID, database: DBName, branch: BranchName, tableName: TableName, recordId: RecordID, options?: GetRecordRequestBody): Promise<XataRecord$1>;
    bulkInsertTableRecords(workspace: WorkspaceID, database: DBName, branch: BranchName, tableName: TableName, records: Record<string, any>[]): Promise<BulkInsertTableRecordsResponse>;
    queryTable(workspace: WorkspaceID, database: DBName, branch: BranchName, tableName: TableName, query: QueryTableRequestBody): Promise<QueryResponse>;
    searchTable(workspace: WorkspaceID, database: DBName, branch: BranchName, tableName: TableName, query: SearchTableRequestBody): Promise<SearchResponse>;
    searchBranch(workspace: WorkspaceID, database: DBName, branch: BranchName, query: SearchBranchRequestBody): Promise<SearchResponse>;
}

declare class XataApiPlugin implements XataPlugin {
    build(options: XataPluginOptions): Promise<XataApiClient>;
}

declare type StringKeys<O> = Extract<keyof O, string>;
declare type Values<O> = O[StringKeys<O>];
declare type UnionToIntersection<T> = (T extends any ? (x: T) => any : never) extends (x: infer R) => any ? R : never;
declare type If<Condition, Then, Else> = Condition extends true ? Then : Else;
declare type IsObject<T> = T extends Record<string, any> ? true : false;
declare type IsArray<T> = T extends Array<any> ? true : false;
declare type NonEmptyArray<T> = T[] & {
    0: T;
};
declare type RequiredBy<T, K extends keyof T> = T & {
    [P in K]-?: NonNullable<T[P]>;
};
declare type GetArrayInnerType<T extends readonly any[]> = T[number];
declare type SingleOrArray<T> = T | T[];
declare type OmitBy<T, K extends keyof T> = T extends any ? Omit<T, K> : never;

declare type SelectableColumn<O, RecursivePath extends any[] = []> = '*' | 'id' | DataProps<O> | NestedColumns<O, RecursivePath>;
declare type SelectedPick<O extends XataRecord, Key extends SelectableColumn<O>[]> = XataRecord & UnionToIntersection<Values<{
    [K in Key[number]]: NestedValueAtColumn<O, K> & XataRecord;
}>>;
declare type ValueAtColumn<O, P extends SelectableColumn<O>> = P extends '*' ? Values<O> : P extends 'id' ? string : P extends keyof O ? O[P] : P extends `${infer K}.${infer V}` ? K extends keyof O ? Values<NonNullable<O[K]> extends infer Item ? Item extends Record<string, any> ? V extends SelectableColumn<Item> ? {
    V: ValueAtColumn<Item, V>;
} : never : O[K] : never> : never : never;
declare type MAX_RECURSION = 5;
declare type NestedColumns<O, RecursivePath extends any[]> = RecursivePath['length'] extends MAX_RECURSION ? never : If<IsObject<O>, Values<{
    [K in DataProps<O>]: NonNullable<O[K]> extends infer Item ? If<IsArray<Item>, K, // If the property is an array, we stop recursion. We don't support object arrays yet
    If<IsObject<Item>, Item extends XataRecord ? SelectableColumn<Item, [...RecursivePath, Item]> extends infer Column ? Column extends string ? K | `${K}.${Column}` : never : never : Item extends Date ? K : `${K}.${StringKeys<Item> | '*'}`, // This allows usage of objects that are not links
    K>> : never;
}>, never>;
declare type DataProps<O> = Exclude<StringKeys<O>, StringKeys<XataRecord>>;
declare type NestedValueAtColumn<O, Key extends SelectableColumn<O>> = Key extends `${infer N}.${infer M}` ? N extends DataProps<O> ? {
    [K in N]: M extends SelectableColumn<NonNullable<O[K]>> ? NonNullable<O[K]> extends XataRecord ? ForwardNullable<O[K], NestedValueAtColumn<NonNullable<O[K]>, M> & XataRecord> : ForwardNullable<O[K], NestedValueAtColumn<NonNullable<O[K]>, M>> : unknown;
} : unknown : Key extends DataProps<O> ? {
    [K in Key]: NonNullable<O[K]> extends XataRecord ? ForwardNullable<O[K], SelectedPick<NonNullable<O[K]>, ['*']>> : O[K];
} : Key extends '*' ? {
    [K in StringKeys<O>]: NonNullable<O[K]> extends XataRecord ? ForwardNullable<O[K], Link<NonNullable<O[K]>>> : O[K];
} : unknown;
declare type ForwardNullable<T, R> = T extends NonNullable<T> ? R : R | null;

/**
 * Represents an identifiable record from the database.
 */
interface Identifiable {
    /**
     * Unique id of this record.
     */
    id: string;
}
interface BaseData {
    [key: string]: any;
}
/**
 * Represents a persisted record from the database.
 */
interface XataRecord<ExtraMetadata extends Record<string, unknown> = Record<string, unknown>> extends Identifiable {
    /**
     * Get metadata of this record.
     */
    getMetadata(): XataRecordMetadata & ExtraMetadata;
    /**
     * Retrieves a refreshed copy of the current record from the database.
     */
    read(): Promise<Readonly<SelectedPick<this, ['*']>> | null>;
    /**
     * Performs a partial update of the current record. On success a new object is
     * returned and the current object is not mutated.
     * @param partialUpdate The columns and their values that have to be updated.
     * @returns A new record containing the latest values for all the columns of the current record.
     */
    update(partialUpdate: Partial<EditableData<Omit<this, keyof XataRecord>>>): Promise<Readonly<SelectedPick<this, ['*']>>>;
    /**
     * Performs a deletion of the current record in the database.
     *
     * @throws If the record was already deleted or if an error happened while performing the deletion.
     */
    delete(): Promise<void>;
}
declare type Link<Record extends XataRecord> = Omit<XataRecord, 'read' | 'update'> & {
    /**
     * Retrieves a refreshed copy of the current record from the database.
     */
    read(): Promise<Readonly<SelectedPick<Record, ['*']>> | null>;
    /**
     * Performs a partial update of the current record. On success a new object is
     * returned and the current object is not mutated.
     * @param partialUpdate The columns and their values that have to be updated.
     * @returns A new record containing the latest values for all the columns of the current record.
     */
    update(partialUpdate: Partial<EditableData<Omit<Record, keyof XataRecord>>>): Promise<Readonly<SelectedPick<Record, ['*']>>>;
};
declare type XataRecordMetadata = {
    /**
     * Number that is increased every time the record is updated.
     */
    version: number;
    warnings?: string[];
};
declare function isIdentifiable(x: any): x is Identifiable & Record<string, unknown>;
declare function isXataRecord(x: any): x is XataRecord & Record<string, unknown>;
declare type EditableData<O extends BaseData> = {
    [K in keyof O]: O[K] extends XataRecord ? {
        id: string;
    } | string : NonNullable<O[K]> extends XataRecord ? {
        id: string;
    } | string | null | undefined : O[K];
};

/**
 * PropertyMatchFilter
 * Example:
{
  "filter": {
    "name": "value",
    "name": {
       "$is":  "value",
       "$any": [ "value1", "value2" ],
    },
    "settings.plan": {"$any": ["free", "paid"]},
    "settings.plan": "free",
    "settings": {
      "plan": "free"
    },
  }
}
*/
declare type PropertyAccessFilter<Record> = {
    [key in SelectableColumn<Record>]?: NestedApiFilter<ValueAtColumn<Record, key>> | PropertyFilter<ValueAtColumn<Record, key>>;
};
declare type PropertyFilter<T> = T | {
    $is: T;
} | {
    $isNot: T;
} | {
    $any: T[];
} | {
    $none: T[];
} | ValueTypeFilters<T>;
declare type IncludesFilter<T> = PropertyFilter<T> | {
    [key in '$all' | '$none' | '$any']?: IncludesFilter<T> | Array<IncludesFilter<T> | {
        $not: IncludesFilter<T>;
    }>;
};
declare type StringTypeFilter = {
    [key in '$contains' | '$pattern' | '$startsWith' | '$endsWith']?: string;
};
declare type ComparableType = number | Date;
declare type ComparableTypeFilter<T extends ComparableType> = {
    [key in '$gt' | '$lt' | '$ge' | '$le']?: T;
};
declare type ArrayFilter<T> = {
    [key in '$includes']?: SingleOrArray<PropertyFilter<T> | ValueTypeFilters<T>> | IncludesFilter<T>;
} | {
    [key in '$includesAll' | '$includesNone' | '$includesAny']?: T | Array<PropertyFilter<T> | {
        $not: PropertyFilter<T>;
    }>;
};
declare type ValueTypeFilters<T> = T | T extends string ? StringTypeFilter : T extends number ? ComparableTypeFilter<number> : T extends Date ? ComparableTypeFilter<Date> : T extends Array<infer T> ? ArrayFilter<T> : never;
/**
 * AggregatorFilter
 * Example:
{
  "filter": {
      "$any": {
        "settings.dark": true,
        "settings.plan": "free"
      }
  },
}
{
  "filter": {
    "$any": [
      {
        "name": "r1",
      },
      {
        "name": "r2",
      },
    ],
}
*/
declare type AggregatorFilter<T> = {
    [key in '$all' | '$any' | '$not' | '$none']?: SingleOrArray<Filter<T>>;
};
/**
 * Existance filter
 * Example: { filter: { $exists: "settings" } }
 */
declare type ExistanceFilter<Record> = {
    [key in '$exists' | '$notExists']?: SelectableColumn<Record>;
};
declare type BaseApiFilter<Record> = PropertyAccessFilter<Record> | AggregatorFilter<Record> | ExistanceFilter<Record>;
/**
 * Nested filter
 * Injects the Api filters on nested properties
 * Example: { filter: { settings: { plan: { $any: ['free', 'trial'] } } } }
 */
declare type NestedApiFilter<T> = {
    [key in keyof T]?: T[key] extends Record<string, any> ? SingleOrArray<Filter<T[key]>> : PropertyFilter<T[key]>;
};
declare type Filter<T> = T extends Record<string, any> ? BaseApiFilter<T> | NestedApiFilter<T> : PropertyFilter<T>;

declare type SortDirection = 'asc' | 'desc';
declare type SortFilterExtended<T extends XataRecord> = {
    column: SelectableColumn<T>;
    direction?: SortDirection;
};
declare type SortFilter<T extends XataRecord> = SelectableColumn<T> | SortFilterExtended<T> | SortFilterBase<T>;
declare type SortFilterBase<T extends XataRecord> = {
    [Key in StringKeys<T>]: SortDirection;
};

declare type BaseOptions<T extends XataRecord> = {
    columns?: NonEmptyArray<SelectableColumn<T>>;
    cache?: number;
};
declare type CursorQueryOptions = {
    pagination?: CursorNavigationOptions & OffsetNavigationOptions;
    filter?: never;
    sort?: never;
};
declare type OffsetQueryOptions<T extends XataRecord> = {
    pagination?: OffsetNavigationOptions;
    filter?: FilterExpression;
    sort?: SortFilter<T> | SortFilter<T>[];
};
declare type QueryOptions<T extends XataRecord> = BaseOptions<T> & (CursorQueryOptions | OffsetQueryOptions<T>);
/**
 * Query objects contain the information of all filters, sorting, etc. to be included in the database query.
 *
 * Query objects are immutable. Any method that adds more constraints or options to the query will return
 * a new Query object containing the both the previous and the new constraints and options.
 */
declare class Query<Record extends XataRecord, Result extends XataRecord = Record> implements Paginable<Record, Result> {
    #private;
    readonly meta: PaginationQueryMeta;
    readonly records: RecordArray<Result>;
    constructor(repository: Repository<Record> | null, table: string, data: Partial<QueryOptions<Record>>, rawParent?: Partial<QueryOptions<Record>>);
    getQueryOptions(): QueryOptions<Record>;
    key(): string;
    /**
     * Builds a new query object representing a logical OR between the given subqueries.
     * @param queries An array of subqueries.
     * @returns A new Query object.
     */
    any(...queries: Query<Record, any>[]): Query<Record, Result>;
    /**
     * Builds a new query object representing a logical AND between the given subqueries.
     * @param queries An array of subqueries.
     * @returns A new Query object.
     */
    all(...queries: Query<Record, any>[]): Query<Record, Result>;
    /**
     * Builds a new query object representing a logical OR negating each subquery. In pseudo-code: !q1 OR !q2
     * @param queries An array of subqueries.
     * @returns A new Query object.
     */
    not(...queries: Query<Record, any>[]): Query<Record, Result>;
    /**
     * Builds a new query object representing a logical AND negating each subquery. In pseudo-code: !q1 AND !q2
     * @param queries An array of subqueries.
     * @returns A new Query object.
     */
    none(...queries: Query<Record, any>[]): Query<Record, Result>;
    /**
     * Builds a new query object adding one or more constraints. Examples:
     *
     * ```
     * query.filter("columnName", columnValue)
     * query.filter("columnName", operator(columnValue)) // Use gt, gte, lt, lte, startsWith,...
     * ```
     *
     * @param column The name of the column to filter.
     * @param value The value to filter.
     * @returns A new Query object.
     */
    filter<F extends SelectableColumn<Record>>(column: F, value: Filter<ValueAtColumn<Record, F>>): Query<Record, Result>;
    /**
     * Builds a new query object adding one or more constraints. Examples:
     *
     * ```
     * query.filter({ "columnName": columnValue })
     * query.filter({
     *   "columnName": operator(columnValue) // Use gt, gte, lt, lte, startsWith,...
     * })
     * ```
     *
     * @param filters A filter object
     * @returns A new Query object.
     */
    filter(filters: Filter<Record>): Query<Record, Result>;
    /**
     * Builds a new query with a new sort option.
     * @param column The column name.
     * @param direction The direction. Either ascending or descending.
     * @returns A new Query object.
     */
    sort<F extends SelectableColumn<Record>>(column: F, direction: SortDirection): Query<Record, Result>;
    /**
     * Builds a new query specifying the set of columns to be returned in the query response.
     * @param columns Array of column names to be returned by the query.
     * @returns A new Query object.
     */
    select<K extends SelectableColumn<Record>>(columns: NonEmptyArray<K>): Query<Record, SelectedPick<Record, NonEmptyArray<K>>>;
    /**
     * Get paginated results
     *
     * @returns A page of results
     */
    getPaginated(): Promise<Page<Record, Result>>;
    /**
     * Get paginated results
     *
     * @param options Pagination options
     * @returns A page of results
     */
    getPaginated(options: OmitBy<QueryOptions<Record>, 'columns'>): Promise<Page<Record, Result>>;
    /**
     * Get paginated results
     *
     * @param options Pagination options
     * @returns A page of results
     */
    getPaginated<Options extends RequiredBy<QueryOptions<Record>, 'columns'>>(options: Options): Promise<Page<Record, SelectedPick<Record, typeof options['columns']>>>;
    /**
     * Get results in an iterator
     *
     * @async
     * @returns Async interable of results
     */
    [Symbol.asyncIterator](): AsyncIterableIterator<Result>;
    /**
     * Build an iterator of results
     *
     * @returns Async generator of results array
     */
    getIterator(): AsyncGenerator<Result[]>;
    /**
     * Build an iterator of results
     *
     * @param options Pagination options with batchSize
     * @returns Async generator of results array
     */
    getIterator(options: OmitBy<QueryOptions<Record>, 'columns' | 'pagination'> & {
        batchSize?: number;
    }): AsyncGenerator<Result[]>;
    /**
     * Build an iterator of results
     *
     * @param options Pagination options with batchSize
     * @returns Async generator of results array
     */
    getIterator<Options extends RequiredBy<OmitBy<QueryOptions<Record>, 'pagination'>, 'columns'> & {
        batchSize?: number;
    }>(options: Options): AsyncGenerator<SelectedPick<Record, typeof options['columns']>[]>;
    /**
     * Performs the query in the database and returns a set of results.
     * @returns An array of records from the database.
     */
    getMany(): Promise<RecordArray<Result>>;
    /**
     * Performs the query in the database and returns a set of results.
     * @param options Additional options to be used when performing the query.
     * @returns An array of records from the database.
     */
    getMany(options: OmitBy<QueryOptions<Record>, 'columns'>): Promise<RecordArray<Result>>;
    /**
     * Performs the query in the database and returns a set of results.
     * @param options Additional options to be used when performing the query.
     * @returns An array of records from the database.
     */
    getMany<Options extends RequiredBy<QueryOptions<Record>, 'columns'>>(options: Options): Promise<RecordArray<SelectedPick<Record, typeof options['columns']>>>;
    /**
     * Performs the query in the database and returns all the results.
     * Warning: If there are a large number of results, this method can have performance implications.
     * @returns An array of records from the database.
     */
    getAll(): Promise<Result[]>;
    /**
     * Performs the query in the database and returns all the results.
     * Warning: If there are a large number of results, this method can have performance implications.
     * @param options Additional options to be used when performing the query.
     * @returns An array of records from the database.
     */
    getAll(options: OmitBy<QueryOptions<Record>, 'columns' | 'pagination'> & {
        batchSize?: number;
    }): Promise<Result[]>;
    /**
     * Performs the query in the database and returns all the results.
     * Warning: If there are a large number of results, this method can have performance implications.
     * @param options Additional options to be used when performing the query.
     * @returns An array of records from the database.
     */
    getAll<Options extends RequiredBy<OmitBy<QueryOptions<Record>, 'pagination'>, 'columns'> & {
        batchSize?: number;
    }>(options: Options): Promise<SelectedPick<Record, typeof options['columns']>[]>;
    /**
     * Performs the query in the database and returns the first result.
     * @returns The first record that matches the query, or null if no record matched the query.
     */
    getFirst(): Promise<Result | null>;
    /**
     * Performs the query in the database and returns the first result.
     * @param options Additional options to be used when performing the query.
     * @returns The first record that matches the query, or null if no record matched the query.
     */
    getFirst(options: OmitBy<QueryOptions<Record>, 'columns' | 'pagination'>): Promise<Result | null>;
    /**
     * Performs the query in the database and returns the first result.
     * @param options Additional options to be used when performing the query.
     * @returns The first record that matches the query, or null if no record matched the query.
     */
    getFirst<Options extends RequiredBy<OmitBy<QueryOptions<Record>, 'pagination'>, 'columns'>>(options: Options): Promise<SelectedPick<Record, typeof options['columns']> | null>;
    /**
     * Builds a new query object adding a cache TTL in milliseconds.
     * @param ttl The cache TTL in milliseconds.
     * @returns A new Query object.
     */
    cache(ttl: number): Query<Record, Result>;
    /**
     * Retrieve next page of records
     *
     * @returns A new page object.
     */
    nextPage(size?: number, offset?: number): Promise<Page<Record, Result>>;
    /**
     * Retrieve previous page of records
     *
     * @returns A new page object
     */
    previousPage(size?: number, offset?: number): Promise<Page<Record, Result>>;
    /**
     * Retrieve first page of records
     *
     * @returns A new page object
     */
    firstPage(size?: number, offset?: number): Promise<Page<Record, Result>>;
    /**
     * Retrieve last page of records
     *
     * @returns A new page object
     */
    lastPage(size?: number, offset?: number): Promise<Page<Record, Result>>;
    /**
     * @returns Boolean indicating if there is a next page
     */
    hasNextPage(): boolean;
}

declare type PaginationQueryMeta = {
    page: {
        cursor: string;
        more: boolean;
    };
};
interface Paginable<Record extends XataRecord, Result extends XataRecord = Record> {
    meta: PaginationQueryMeta;
    records: RecordArray<Result>;
    nextPage(size?: number, offset?: number): Promise<Page<Record, Result>>;
    previousPage(size?: number, offset?: number): Promise<Page<Record, Result>>;
    firstPage(size?: number, offset?: number): Promise<Page<Record, Result>>;
    lastPage(size?: number, offset?: number): Promise<Page<Record, Result>>;
    hasNextPage(): boolean;
}
/**
 * A Page contains a set of results from a query plus metadata about the retrieved
 * set of values such as the cursor, required to retrieve additional records.
 */
declare class Page<Record extends XataRecord, Result extends XataRecord = Record> implements Paginable<Record, Result> {
    #private;
    /**
     * Page metadata, required to retrieve additional records.
     */
    readonly meta: PaginationQueryMeta;
    /**
     * The set of results for this page.
     */
    readonly records: RecordArray<Result>;
    constructor(query: Query<Record, Result>, meta: PaginationQueryMeta, records?: Result[]);
    /**
     * Retrieves the next page of results.
     * @param size Maximum number of results to be retrieved.
     * @param offset Number of results to skip when retrieving the results.
     * @returns The next page or results.
     */
    nextPage(size?: number, offset?: number): Promise<Page<Record, Result>>;
    /**
     * Retrieves the previous page of results.
     * @param size Maximum number of results to be retrieved.
     * @param offset Number of results to skip when retrieving the results.
     * @returns The previous page or results.
     */
    previousPage(size?: number, offset?: number): Promise<Page<Record, Result>>;
    /**
     * Retrieves the first page of results.
     * @param size Maximum number of results to be retrieved.
     * @param offset Number of results to skip when retrieving the results.
     * @returns The first page or results.
     */
    firstPage(size?: number, offset?: number): Promise<Page<Record, Result>>;
    /**
     * Retrieves the last page of results.
     * @param size Maximum number of results to be retrieved.
     * @param offset Number of results to skip when retrieving the results.
     * @returns The last page or results.
     */
    lastPage(size?: number, offset?: number): Promise<Page<Record, Result>>;
    /**
     * Shortcut method to check if there will be additional results if the next page of results is retrieved.
     * @returns Whether or not there will be additional results in the next page of results.
     */
    hasNextPage(): boolean;
}
declare type CursorNavigationOptions = {
    first?: string;
} | {
    last?: string;
} | {
    after?: string;
    before?: string;
};
declare type OffsetNavigationOptions = {
    size?: number;
    offset?: number;
};
declare const PAGINATION_MAX_SIZE = 200;
declare const PAGINATION_DEFAULT_SIZE = 20;
declare const PAGINATION_MAX_OFFSET = 800;
declare const PAGINATION_DEFAULT_OFFSET = 0;
declare function isCursorPaginationOptions(options: Record<string, unknown> | undefined | null): options is CursorNavigationOptions;
declare class RecordArray<Result extends XataRecord> extends Array<Result> {
    #private;
    constructor(page: Paginable<any, Result>, overrideRecords?: Result[]);
    static parseConstructorParams(...args: any[]): any[];
    /**
     * Retrieve next page of records
     *
     * @returns A new array of objects
     */
    nextPage(size?: number, offset?: number): Promise<RecordArray<Result>>;
    /**
     * Retrieve previous page of records
     *
     * @returns A new array of objects
     */
    previousPage(size?: number, offset?: number): Promise<RecordArray<Result>>;
    /**
     * Retrieve first page of records
     *
     * @returns A new array of objects
     */
    firstPage(size?: number, offset?: number): Promise<RecordArray<Result>>;
    /**
     * Retrieve last page of records
     *
     * @returns A new array of objects
     */
    lastPage(size?: number, offset?: number): Promise<RecordArray<Result>>;
    /**
     * @returns Boolean indicating if there is a next page
     */
    hasNextPage(): boolean;
}

/**
 * Common interface for performing operations on a table.
 */
declare abstract class Repository<Data extends BaseData, Record extends XataRecord = Data & XataRecord> extends Query<Record, Readonly<SelectedPick<Record, ['*']>>> {
    abstract create(object: EditableData<Data> & Partial<Identifiable>): Promise<Readonly<SelectedPick<Record, ['*']>>>;
    /**
     * Creates a single record in the table with a unique id.
     * @param id The unique id.
     * @param object Object containing the column names with their values to be stored in the table.
     * @returns The full persisted record.
     */
    abstract create(id: string, object: EditableData<Data>): Promise<Readonly<SelectedPick<Record, ['*']>>>;
    /**
     * Creates multiple records in the table.
     * @param objects Array of objects with the column names and the values to be stored in the table.
     * @returns Array of the persisted records.
     */
    abstract create(objects: Array<EditableData<Data> & Partial<Identifiable>>): Promise<Readonly<SelectedPick<Record, ['*']>>[]>;
    /**
     * Queries a single record from the table given its unique id.
     * @param id The unique id.
     * @returns The persisted record for the given id or null if the record could not be found.
     */
    abstract read(id: string): Promise<Readonly<SelectedPick<Record, ['*']> | null>>;
    /**
     * Queries multiple records from the table given their unique id.
     * @param ids The unique ids array.
     * @returns The persisted records for the given ids (if a record could not be found it is not returned).
     */
    abstract read(ids: string[]): Promise<Array<Readonly<SelectedPick<Record, ['*']>>>>;
    /**
     * Queries a single record from the table by the id in the object.
     * @param object Object containing the id of the record.
     * @returns The persisted record for the given id or null if the record could not be found.
     */
    abstract read(object: Identifiable): Promise<Readonly<SelectedPick<Record, ['*']> | null>>;
    /**
     * Queries multiple records from the table by the ids in the objects.
     * @param objects Array of objects containing the ids of the records.
     * @returns The persisted records for the given ids (if a record could not be found it is not returned).
     */
    abstract read(objects: Identifiable[]): Promise<Array<Readonly<SelectedPick<Record, ['*']>>>>;
    /**
     * Partially update a single record.
     * @param object An object with its id and the columns to be updated.
     * @returns The full persisted record.
     */
    abstract update(object: Partial<EditableData<Data>> & Identifiable): Promise<Readonly<SelectedPick<Record, ['*']>>>;
    /**
     * Partially update a single record given its unique id.
     * @param id The unique id.
     * @param object The column names and their values that have to be updated.
     * @returns The full persisted record.
     */
    abstract update(id: string, object: Partial<EditableData<Data>>): Promise<Readonly<SelectedPick<Record, ['*']>>>;
    /**
     * Partially updates multiple records.
     * @param objects An array of objects with their ids and columns to be updated.
     * @returns Array of the persisted records.
     */
    abstract update(objects: Array<Partial<EditableData<Data>> & Identifiable>): Promise<Readonly<SelectedPick<Record, ['*']>>[]>;
    /**
     * Creates or updates a single record. If a record exists with the given id,
     * it will be update, otherwise a new record will be created.
     * @param object Object containing the column names with their values to be persisted in the table.
     * @returns The full persisted record.
     */
    abstract createOrUpdate(object: EditableData<Data> & Identifiable): Promise<Readonly<SelectedPick<Record, ['*']>>>;
    /**
     * Creates or updates a single record. If a record exists with the given id,
     * it will be update, otherwise a new record will be created.
     * @param id A unique id.
     * @param object The column names and the values to be persisted.
     * @returns The full persisted record.
     */
    abstract createOrUpdate(id: string, object: EditableData<Data>): Promise<Readonly<SelectedPick<Record, ['*']>>>;
    /**
     * Creates or updates a single record. If a record exists with the given id,
     * it will be update, otherwise a new record will be created.
     * @param objects Array of objects with the column names and the values to be stored in the table.
     * @returns Array of the persisted records.
     */
    abstract createOrUpdate(objects: Array<EditableData<Data> & Identifiable>): Promise<Readonly<SelectedPick<Record, ['*']>>[]>;
    /**
     * Deletes a record given its unique id.
     * @param id The unique id.
     * @throws If the record could not be found or there was an error while performing the deletion.
     */
    abstract delete(id: string): Promise<void>;
    /**
     * Deletes a record given its unique id.
     * @param id An object with a unique id.
     * @throws If the record could not be found or there was an error while performing the deletion.
     */
    abstract delete(id: Identifiable): Promise<void>;
    /**
     * Deletes a record given a list of unique ids.
     * @param ids The array of unique ids.
     * @throws If the record could not be found or there was an error while performing the deletion.
     */
    abstract delete(ids: string[]): Promise<void>;
    /**
     * Deletes a record given a list of unique ids.
     * @param ids An array of objects with unique ids.
     * @throws If the record could not be found or there was an error while performing the deletion.
     */
    abstract delete(ids: Identifiable[]): Promise<void>;
    /**
     * Search for records in the table.
     * @param query The query to search for.
     * @param options The options to search with (like: fuzziness)
     * @returns The found records.
     */
    abstract search(query: string, options?: {
        fuzziness?: FuzzinessExpression;
        highlight?: HighlightExpression;
        filter?: Filter<Record>;
    }): Promise<SelectedPick<Record, ['*']>[]>;
    abstract query<Result extends XataRecord>(query: Query<Record, Result>): Promise<Page<Record, Result>>;
}
declare class RestRepository<Data extends BaseData, Record extends XataRecord = Data & XataRecord> extends Query<Record, SelectedPick<Record, ['*']>> implements Repository<Data, Record> {
    #private;
    db: SchemaPluginResult<any>;
    constructor(options: {
        table: string;
        db: SchemaPluginResult<any>;
        pluginOptions: XataPluginOptions;
    });
    create(object: EditableData<Data>): Promise<SelectedPick<Record, ['*']>>;
    create(recordId: string, object: EditableData<Data>): Promise<SelectedPick<Record, ['*']>>;
    create(objects: EditableData<Data>[]): Promise<SelectedPick<Record, ['*']>[]>;
    read(recordId: string): Promise<SelectedPick<Record, ['*']> | null>;
    read(recordIds: string[]): Promise<Array<Readonly<SelectedPick<Record, ['*']>>>>;
    read(object: Identifiable): Promise<SelectedPick<Record, ['*']> | null>;
    read(objects: Identifiable[]): Promise<Array<Readonly<SelectedPick<Record, ['*']>>>>;
    update(object: Partial<EditableData<Data>> & Identifiable): Promise<SelectedPick<Record, ['*']>>;
    update(recordId: string, object: Partial<EditableData<Data>>): Promise<SelectedPick<Record, ['*']>>;
    update(objects: Array<Partial<EditableData<Data>> & Identifiable>): Promise<SelectedPick<Record, ['*']>[]>;
    createOrUpdate(object: EditableData<Data>): Promise<SelectedPick<Record, ['*']>>;
    createOrUpdate(recordId: string, object: EditableData<Data>): Promise<SelectedPick<Record, ['*']>>;
    createOrUpdate(objects: EditableData<Data>[]): Promise<SelectedPick<Record, ['*']>[]>;
    delete(a: string | Identifiable | Array<string | Identifiable>): Promise<void>;
    search(query: string, options?: {
        fuzziness?: FuzzinessExpression;
        highlight?: HighlightExpression;
        filter?: Filter<Record>;
    }): Promise<SelectedPick<Record, ['*']>[]>;
    query<Result extends XataRecord>(query: Query<Record, Result>): Promise<Page<Record, Result>>;
}

/**
 * Operator to restrict results to only values that are greater than the given value.
 */
declare const gt: <T extends ComparableType>(value: T) => ComparableTypeFilter<T>;
/**
 * Operator to restrict results to only values that are greater than or equal to the given value.
 */
declare const ge: <T extends ComparableType>(value: T) => ComparableTypeFilter<T>;
/**
 * Operator to restrict results to only values that are greater than or equal to the given value.
 */
declare const gte: <T extends ComparableType>(value: T) => ComparableTypeFilter<T>;
/**
 * Operator to restrict results to only values that are lower than the given value.
 */
declare const lt: <T extends ComparableType>(value: T) => ComparableTypeFilter<T>;
/**
 * Operator to restrict results to only values that are lower than or equal to the given value.
 */
declare const lte: <T extends ComparableType>(value: T) => ComparableTypeFilter<T>;
/**
 * Operator to restrict results to only values that are lower than or equal to the given value.
 */
declare const le: <T extends ComparableType>(value: T) => ComparableTypeFilter<T>;
/**
 * Operator to restrict results to only values that are not null.
 */
declare const exists: <T>(column: SelectableColumn<T, []>) => ExistanceFilter<T>;
/**
 * Operator to restrict results to only values that are null.
 */
declare const notExists: <T>(column: SelectableColumn<T, []>) => ExistanceFilter<T>;
/**
 * Operator to restrict results to only values that start with the given prefix.
 */
declare const startsWith: (value: string) => StringTypeFilter;
/**
 * Operator to restrict results to only values that end with the given suffix.
 */
declare const endsWith: (value: string) => StringTypeFilter;
/**
 * Operator to restrict results to only values that match the given pattern.
 */
declare const pattern: (value: string) => StringTypeFilter;
/**
 * Operator to restrict results to only values that are equal to the given value.
 */
declare const is: <T>(value: T) => PropertyFilter<T>;
/**
 * Operator to restrict results to only values that are not equal to the given value.
 */
declare const isNot: <T>(value: T) => PropertyFilter<T>;
/**
 * Operator to restrict results to only values that contain the given value.
 */
declare const contains: (value: string) => StringTypeFilter;
/**
 * Operator to restrict results if some array items match the predicate.
 */
declare const includes: <T>(value: T) => ArrayFilter<T>;
/**
 * Operator to restrict results if all array items match the predicate.
 */
declare const includesAll: <T>(value: T) => ArrayFilter<T>;
/**
 * Operator to restrict results if none array items match the predicate.
 */
declare const includesNone: <T>(value: T) => ArrayFilter<T>;
/**
 * Operator to restrict results if some array items match the predicate.
 */
declare const includesAny: <T>(value: T) => ArrayFilter<T>;

declare type SchemaDefinition = {
    table: string;
};
declare type SchemaPluginResult<Schemas extends Record<string, BaseData>> = {
    [Key in keyof Schemas]: Repository<Schemas[Key]>;
} & {
    [key: string]: Repository<XataRecord$1>;
};
declare class SchemaPlugin<Schemas extends Record<string, BaseData>> extends XataPlugin {
    #private;
    private tableNames?;
    constructor(tableNames?: string[] | undefined);
    build(pluginOptions: XataPluginOptions): SchemaPluginResult<Schemas>;
}

declare type SearchOptions<Schemas extends Record<string, BaseData>, Tables extends StringKeys<Schemas>> = {
    fuzziness?: FuzzinessExpression;
    highlight?: HighlightExpression;
    tables?: Array<Tables | Values<{
        [Model in GetArrayInnerType<NonNullable<Tables[]>>]: {
            table: Model;
            filter?: Filter<SelectedPick<Schemas[Model] & SearchXataRecord, ['*']>>;
        };
    }>>;
};
declare type SearchPluginResult<Schemas extends Record<string, BaseData>> = {
    all: <Tables extends StringKeys<Schemas>>(query: string, options?: SearchOptions<Schemas, Tables>) => Promise<Values<{
        [Model in ExtractTables<Schemas, Tables, GetArrayInnerType<NonNullable<NonNullable<typeof options>['tables']>>>]: {
            table: Model;
            record: Awaited<SelectedPick<Schemas[Model] & SearchXataRecord, ['*']>>;
        };
    }>[]>;
    byTable: <Tables extends StringKeys<Schemas>>(query: string, options?: SearchOptions<Schemas, Tables>) => Promise<{
        [Model in ExtractTables<Schemas, Tables, GetArrayInnerType<NonNullable<NonNullable<typeof options>['tables']>>>]?: Awaited<SelectedPick<Schemas[Model] & SearchXataRecord, ['*']>[]>;
    }>;
};
declare class SearchPlugin<Schemas extends Record<string, BaseData>> extends XataPlugin {
    #private;
    private db;
    constructor(db: SchemaPluginResult<Schemas>);
    build({ getFetchProps }: XataPluginOptions): SearchPluginResult<Schemas>;
}
declare type SearchXataRecord = XataRecord<SearchExtraProperties>;
declare type SearchExtraProperties = {
    table: string;
    highlight?: {
        [key: string]: string[] | {
            [key: string]: any;
        };
    };
};
declare type ReturnTable<Table, Tables> = Table extends Tables ? Table : never;
declare type ExtractTables<Schemas extends Record<string, BaseData>, Tables extends StringKeys<Schemas>, TableOptions extends GetArrayInnerType<NonNullable<NonNullable<SearchOptions<Schemas, Tables>>['tables']>>> = TableOptions extends `${infer Table}` ? ReturnTable<Table, Tables> : TableOptions extends {
    table: infer Table;
} ? ReturnTable<Table, Tables> : never;

declare type BranchStrategyValue = string | undefined | null;
declare type BranchStrategyBuilder = () => BranchStrategyValue | Promise<BranchStrategyValue>;
declare type BranchStrategy = BranchStrategyValue | BranchStrategyBuilder;
declare type BranchStrategyOption = NonNullable<BranchStrategy | BranchStrategy[]>;

declare type BaseClientOptions = {
    fetch?: FetchImpl;
    apiKey?: string;
    databaseURL?: string;
    branch?: BranchStrategyOption;
    cache?: CacheImpl;
};
declare const buildClient: <Plugins extends Record<string, XataPlugin> = {}>(plugins?: Plugins | undefined) => ClientConstructor<Plugins>;
interface ClientConstructor<Plugins extends Record<string, XataPlugin>> {
    new <Schemas extends Record<string, BaseData> = {}>(options?: Partial<BaseClientOptions>, tables?: string[]): Omit<{
        db: Awaited<ReturnType<SchemaPlugin<Schemas>['build']>>;
        search: Awaited<ReturnType<SearchPlugin<Schemas>['build']>>;
    }, keyof Plugins> & {
        [Key in StringKeys<NonNullable<Plugins>>]: Awaited<ReturnType<NonNullable<Plugins>[Key]['build']>>;
    };
}
declare const BaseClient_base: ClientConstructor<{}>;
declare class BaseClient extends BaseClient_base<Record<string, any>> {
}

declare type BranchResolutionOptions = {
    databaseURL?: string;
    apiKey?: string;
    fetchImpl?: FetchImpl;
};
declare function getCurrentBranchName(options?: BranchResolutionOptions): Promise<string>;
declare function getCurrentBranchDetails(options?: BranchResolutionOptions): Promise<DBBranch | null>;
declare function getDatabaseURL(): string | undefined;

declare function getAPIKey(): string | undefined;

declare class XataError extends Error {
    readonly status: number;
    constructor(message: string, status: number);
}

export { AcceptWorkspaceMemberInviteError, AcceptWorkspaceMemberInvitePathParams, AcceptWorkspaceMemberInviteVariables, AddGitBranchesEntryError, AddGitBranchesEntryPathParams, AddGitBranchesEntryRequestBody, AddGitBranchesEntryResponse, AddGitBranchesEntryVariables, AddTableColumnError, AddTableColumnPathParams, AddTableColumnVariables, BaseClient, BaseClientOptions, BaseData, BulkInsertTableRecordsError, BulkInsertTableRecordsPathParams, BulkInsertTableRecordsRequestBody, BulkInsertTableRecordsResponse, BulkInsertTableRecordsVariables, CacheImpl, CancelWorkspaceMemberInviteError, CancelWorkspaceMemberInvitePathParams, CancelWorkspaceMemberInviteVariables, ClientConstructor, CreateBranchError, CreateBranchPathParams, CreateBranchQueryParams, CreateBranchRequestBody, CreateBranchVariables, CreateDatabaseError, CreateDatabasePathParams, CreateDatabaseRequestBody, CreateDatabaseResponse, CreateDatabaseVariables, CreateTableError, CreateTablePathParams, CreateTableVariables, CreateUserAPIKeyError, CreateUserAPIKeyPathParams, CreateUserAPIKeyResponse, CreateUserAPIKeyVariables, CreateWorkspaceError, CreateWorkspaceVariables, CursorNavigationOptions, DeleteBranchError, DeleteBranchPathParams, DeleteBranchVariables, DeleteColumnError, DeleteColumnPathParams, DeleteColumnVariables, DeleteDatabaseError, DeleteDatabasePathParams, DeleteDatabaseVariables, DeleteRecordError, DeleteRecordPathParams, DeleteRecordVariables, DeleteTableError, DeleteTablePathParams, DeleteTableVariables, DeleteUserAPIKeyError, DeleteUserAPIKeyPathParams, DeleteUserAPIKeyVariables, DeleteUserError, DeleteUserVariables, DeleteWorkspaceError, DeleteWorkspacePathParams, DeleteWorkspaceVariables, EditableData, ExecuteBranchMigrationPlanError, ExecuteBranchMigrationPlanPathParams, ExecuteBranchMigrationPlanRequestBody, ExecuteBranchMigrationPlanVariables, FetchImpl, FetcherExtraProps, GetBranchDetailsError, GetBranchDetailsPathParams, GetBranchDetailsVariables, GetBranchListError, GetBranchListPathParams, GetBranchListVariables, GetBranchMetadataError, GetBranchMetadataPathParams, GetBranchMetadataVariables, GetBranchMigrationHistoryError, GetBranchMigrationHistoryPathParams, GetBranchMigrationHistoryRequestBody, GetBranchMigrationHistoryResponse, GetBranchMigrationHistoryVariables, GetBranchMigrationPlanError, GetBranchMigrationPlanPathParams, GetBranchMigrationPlanVariables, GetBranchStatsError, GetBranchStatsPathParams, GetBranchStatsResponse, GetBranchStatsVariables, GetColumnError, GetColumnPathParams, GetColumnVariables, GetDatabaseListError, GetDatabaseListPathParams, GetDatabaseListVariables, GetGitBranchesMappingError, GetGitBranchesMappingPathParams, GetGitBranchesMappingVariables, GetRecordError, GetRecordPathParams, GetRecordRequestBody, GetRecordVariables, GetTableColumnsError, GetTableColumnsPathParams, GetTableColumnsResponse, GetTableColumnsVariables, GetTableSchemaError, GetTableSchemaPathParams, GetTableSchemaResponse, GetTableSchemaVariables, GetUserAPIKeysError, GetUserAPIKeysResponse, GetUserAPIKeysVariables, GetUserError, GetUserVariables, GetWorkspaceError, GetWorkspaceMembersListError, GetWorkspaceMembersListPathParams, GetWorkspaceMembersListVariables, GetWorkspacePathParams, GetWorkspaceVariables, GetWorkspacesListError, GetWorkspacesListResponse, GetWorkspacesListVariables, Identifiable, InsertRecordError, InsertRecordPathParams, InsertRecordResponse, InsertRecordVariables, InsertRecordWithIDError, InsertRecordWithIDPathParams, InsertRecordWithIDQueryParams, InsertRecordWithIDVariables, InviteWorkspaceMemberError, InviteWorkspaceMemberPathParams, InviteWorkspaceMemberRequestBody, InviteWorkspaceMemberVariables, OffsetNavigationOptions, operationsByTag as Operations, PAGINATION_DEFAULT_OFFSET, PAGINATION_DEFAULT_SIZE, PAGINATION_MAX_OFFSET, PAGINATION_MAX_SIZE, Page, Paginable, PaginationQueryMeta, Query, QueryTableError, QueryTablePathParams, QueryTableRequestBody, QueryTableVariables, RecordArray, RemoveGitBranchesEntryError, RemoveGitBranchesEntryPathParams, RemoveGitBranchesEntryQueryParams, RemoveGitBranchesEntryVariables, RemoveWorkspaceMemberError, RemoveWorkspaceMemberPathParams, RemoveWorkspaceMemberVariables, Repository, ResendWorkspaceMemberInviteError, ResendWorkspaceMemberInvitePathParams, ResendWorkspaceMemberInviteVariables, ResolveBranchError, ResolveBranchPathParams, ResolveBranchQueryParams, ResolveBranchResponse, ResolveBranchVariables, responses as Responses, RestRepository, SchemaDefinition, SchemaPlugin, SchemaPluginResult, schemas as Schemas, SearchBranchError, SearchBranchPathParams, SearchBranchRequestBody, SearchBranchVariables, SearchOptions, SearchPlugin, SearchPluginResult, SearchTableError, SearchTablePathParams, SearchTableRequestBody, SearchTableVariables, SelectableColumn, SelectedPick, SetTableSchemaError, SetTableSchemaPathParams, SetTableSchemaRequestBody, SetTableSchemaVariables, SimpleCache, SimpleCacheOptions, UpdateBranchMetadataError, UpdateBranchMetadataPathParams, UpdateBranchMetadataVariables, UpdateColumnError, UpdateColumnPathParams, UpdateColumnRequestBody, UpdateColumnVariables, UpdateRecordWithIDError, UpdateRecordWithIDPathParams, UpdateRecordWithIDQueryParams, UpdateRecordWithIDVariables, UpdateTableError, UpdateTablePathParams, UpdateTableRequestBody, UpdateTableVariables, UpdateUserError, UpdateUserVariables, UpdateWorkspaceError, UpdateWorkspaceMemberRoleError, UpdateWorkspaceMemberRolePathParams, UpdateWorkspaceMemberRoleRequestBody, UpdateWorkspaceMemberRoleVariables, UpdateWorkspacePathParams, UpdateWorkspaceVariables, UpsertRecordWithIDError, UpsertRecordWithIDPathParams, UpsertRecordWithIDQueryParams, UpsertRecordWithIDVariables, ValueAtColumn, XataApiClient, XataApiClientOptions, XataApiPlugin, XataError, XataPlugin, XataPluginOptions, XataRecord, acceptWorkspaceMemberInvite, addGitBranchesEntry, addTableColumn, buildClient, bulkInsertTableRecords, cancelWorkspaceMemberInvite, contains, createBranch, createDatabase, createTable, createUserAPIKey, createWorkspace, deleteBranch, deleteColumn, deleteDatabase, deleteRecord, deleteTable, deleteUser, deleteUserAPIKey, deleteWorkspace, endsWith, executeBranchMigrationPlan, exists, ge, getAPIKey, getBranchDetails, getBranchList, getBranchMetadata, getBranchMigrationHistory, getBranchMigrationPlan, getBranchStats, getColumn, getCurrentBranchDetails, getCurrentBranchName, getDatabaseList, getDatabaseURL, getGitBranchesMapping, getRecord, getTableColumns, getTableSchema, getUser, getUserAPIKeys, getWorkspace, getWorkspaceMembersList, getWorkspacesList, gt, gte, includes, includesAll, includesAny, includesNone, insertRecord, insertRecordWithID, inviteWorkspaceMember, is, isCursorPaginationOptions, isIdentifiable, isNot, isXataRecord, le, lt, lte, notExists, operationsByTag, pattern, queryTable, removeGitBranchesEntry, removeWorkspaceMember, resendWorkspaceMemberInvite, resolveBranch, searchBranch, searchTable, setTableSchema, startsWith, updateBranchMetadata, updateColumn, updateRecordWithID, updateTable, updateUser, updateWorkspace, updateWorkspaceMemberRole, upsertRecordWithID };
